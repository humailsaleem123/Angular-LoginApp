import { Component, Input, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxGroupByAreaDirective } from './group-by-area.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
import * as i2 from "@angular/common";
import * as i3 from "../../icon/icon.component";
import * as i4 from "../../directives/suffix/suffix.directive";
import * as i5 from "../../chips/chips-area.component";
import * as i6 from "../../chips/chip.component";
import * as i7 from "../../directives/drag-drop/drag-drop.directive";
import * as i8 from "../grid/grid.directives";
import * as i9 from "./group-by-area.directive";
/**
 * An internal component representing the group-by drop area for the igx-grid component.
 *
 * @hidden @internal
 */
export class IgxTreeGridGroupByAreaComponent extends IgxGroupByAreaDirective {
    constructor(differs, ref, platform) {
        super(ref, platform);
        this.differs = differs;
        this._hideGroupedColumns = false;
        this.destroy$ = new Subject();
    }
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (this.grid.columns && this.expressions) {
            this.setColumnsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    ngAfterContentInit() {
        if (this.grid.columns && this.expressions) {
            this.groupingDiffer = this.differs.find(this.expressions).create();
            this.updateColumnsVisibility();
        }
        this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe((sortingExpressions) => {
            if (!this.expressions || !this.expressions.length) {
                return;
            }
            let changed = false;
            sortingExpressions.forEach((sortExpr) => {
                const fieldName = sortExpr.fieldName;
                const groupingExpr = this.expressions.find(ex => ex.fieldName === fieldName);
                if (groupingExpr && groupingExpr.dir !== sortExpr.dir) {
                    groupingExpr.dir = sortExpr.dir;
                    changed = true;
                }
            });
            if (changed) {
                this.expressions = [...this.expressions];
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    handleReorder(event) {
        const { chipsArray, originalEvent } = event;
        const newExpressions = this.getReorderedExpressions(chipsArray);
        this.chipExpressions = newExpressions;
        // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
        if (originalEvent instanceof KeyboardEvent) {
            this.expressions = newExpressions;
        }
    }
    handleMoveEnd() {
        this.expressions = this.chipExpressions;
    }
    groupBy(expression) {
        this.expressions.push(expression);
        this.expressions = [...this.expressions];
    }
    clearGrouping(name) {
        this.expressions = this.expressions.filter(item => item.fieldName !== name);
        this.grid.sortingExpressions = this.grid.sortingExpressions.filter(item => item.fieldName !== name);
        this.grid.notifyChanges(true);
    }
    expressionsChanged() {
        this.updateColumnsVisibility();
    }
    updateColumnsVisibility() {
        if (this.groupingDiffer && this.grid.columns && !this.grid.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.expressions);
            if (changes && this.grid.columns.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = this.hideGroupedColumns;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    }
    setColumnsVisibility(value) {
        if (this.grid.columns.length > 0 && !this.grid.hasColumnLayouts) {
            this.expressions.forEach((expr) => {
                const col = this.grid.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
}
IgxTreeGridGroupByAreaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Component });
IgxTreeGridGroupByAreaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxTreeGridGroupByAreaComponent, selector: "igx-tree-grid-group-by-area", inputs: { hideGroupedColumns: "hideGroupedColumns" }, providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], usesInheritance: true, ngImport: i0, template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\n        <igx-chip\n            [id]=\"expression.fieldName\"\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid).title\"\n            [displayDensity]=\"grid.displayDensity\"\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\n            (remove)=\"clearGrouping($event.owner.id)\"\n            (chipClick)=\"handleClick(expression.fieldName)\"\n        >\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid).title }}</span>\n            <igx-icon igxSuffix>{{ expression.dir === 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n        </igx-chip>\n\n        <span class=\"igx-grid-grouparea__connector\">\n            <igx-icon [hidden]=\"(last && !dropAreaVisible)\">arrow_forward</igx-icon>\n        </span>\n    </ng-container>\n    <div igxGroupAreaDrop class=\"igx-drop-area{{ density !== 'comfortable' ? '--' + density : ''}}\"\n        [attr.gridId]=\"grid.id\"\n        [hidden]=\"!dropAreaVisible\"\n        (igxDrop)=\"onDragDrop($event)\"\n    >\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\n    </div>\n</igx-chips-area>\n\n<ng-template #default>\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i3.IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: i4.IgxSuffixDirective, selector: "igx-suffix,[igxSuffix]" }, { kind: "component", type: i5.IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["class", "width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "component", type: i6.IgxChipComponent, selector: "igx-chip", inputs: ["id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "directive", type: i7.IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "directive", type: i8.IgxGroupAreaDropDirective, selector: "[igxGroupAreaDrop]" }, { kind: "pipe", type: i9.IgxGroupByMetaPipe, name: "igxGroupByMeta" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree-grid-group-by-area', providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\n        <igx-chip\n            [id]=\"expression.fieldName\"\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid).title\"\n            [displayDensity]=\"grid.displayDensity\"\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid).groupable\"\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\n            (remove)=\"clearGrouping($event.owner.id)\"\n            (chipClick)=\"handleClick(expression.fieldName)\"\n        >\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid).title }}</span>\n            <igx-icon igxSuffix>{{ expression.dir === 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n        </igx-chip>\n\n        <span class=\"igx-grid-grouparea__connector\">\n            <igx-icon [hidden]=\"(last && !dropAreaVisible)\">arrow_forward</igx-icon>\n        </span>\n    </ng-container>\n    <div igxGroupAreaDrop class=\"igx-drop-area{{ density !== 'comfortable' ? '--' + density : ''}}\"\n        [attr.gridId]=\"grid.id\"\n        [hidden]=\"!dropAreaVisible\"\n        (igxDrop)=\"onDragDrop($event)\"\n    >\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\n    </div>\n</igx-chips-area>\n\n<ng-template #default>\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.IterableDiffers }, { type: i0.ElementRef }, { type: i1.PlatformUtil }]; }, propDecorators: { hideGroupedColumns: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2dyb3VwaW5nL3RyZWUtZ3JpZC1ncm91cC1ieS1hcmVhLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9ncm91cGluZy9ncm91cC1ieS1hcmVhLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBRVQsS0FBSyxHQUlSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSzNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDOzs7Ozs7Ozs7OztBQUVwRTs7OztHQUlHO0FBTUgsTUFBTSxPQUFPLCtCQUFnQyxTQUFRLHVCQUF1QjtJQWtCeEUsWUFBb0IsT0FBd0IsRUFBRSxHQUE0QixFQUFFLFFBQXNCO1FBQzlGLEtBQUssQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFETCxZQUFPLEdBQVAsT0FBTyxDQUFpQjtRQUpwQyx3QkFBbUIsR0FBRyxLQUFLLENBQUM7UUFFNUIsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7SUFJdEMsQ0FBQztJQW5CRCxJQUNXLGtCQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztJQUNwQyxDQUFDO0lBRUQsSUFBVyxrQkFBa0IsQ0FBQyxLQUFjO1FBQ3hDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUN2QyxJQUFJLENBQUMs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QUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUM3RCxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUM5QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3RELEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDOzs0SEE3R1EsK0JBQStCO2dIQUEvQiwrQkFBK0IsNEdBRjdCLENBQUMsRUFBRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsV0FBVyxFQUFFLCtCQUErQixFQUFFLENBQUMsaURDekJuRyxndERBa0NBOzJGRFBhLCtCQUErQjtrQkFMM0MsU0FBUzsrQkFDSSw2QkFBNkIsYUFFNUIsQ0FBQyxFQUFFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxXQUFXLGlDQUFpQyxFQUFFLENBQUM7MEpBSXBGLGtCQUFrQjtzQkFENUIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBJdGVyYWJsZURpZmZlcixcbiAgICBJdGVyYWJsZURpZmZlcnMsXG4gICAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUgfSBmcm9tICcuL2dyb3VwLWJ5LWFyZWEuZGlyZWN0aXZlJztcblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBncm91cC1ieSBkcm9wIGFyZWEgZm9yIHRoZSBpZ3gtZ3JpZCBjb21wb25lbnQuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEnLFxuICAgIHRlbXBsYXRlVXJsOiAnZ3JvdXAtYnktYXJlYS5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hHcm91cEJ5QXJlYURpcmVjdGl2ZSwgdXNlRXhpc3Rpbmc6IElneFRyZWVHcmlkR3JvdXBCeUFyZWFDb21wb25lbnQgfV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRHcm91cEJ5QXJlYUNvbXBvbmVudCBleHRlbmRzIElneEdyb3VwQnlBcmVhRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaGlkZUdyb3VwZWRDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgaGlkZUdyb3VwZWRDb2x1bW5zKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuY29sdW1ucyAmJiB0aGlzLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbHVtbnNWaXNpYmlsaXR5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hpZGVHcm91cGVkQ29sdW1ucyA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hpZGVHcm91cGVkQ29sdW1ucyA9IGZhbHNlO1xuICAgIHByaXZhdGUgZ3JvdXBpbmdEaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPElHcm91cGluZ0V4cHJlc3Npb24+O1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgcmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcGxhdGZvcm06IFBsYXRmb3JtVXRpbCkge1xuICAgICAgICBzdXBlcihyZWYsIHBsYXRmb3JtKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmNvbHVtbnMgJiYgdGhpcy5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0RpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMuZXhwcmVzc2lvbnMpLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5zVmlzaWJpbGl0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkLnNvcnRpbmdFeHByZXNzaW9uc0NoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChzb3J0aW5nRXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXhwcmVzc2lvbnMgfHwgIXRoaXMuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzb3J0aW5nRXhwcmVzc2lvbnMuZm9yRWFjaCgoc29ydEV4cHI6IElTb3J0aW5nRXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHNvcnRFeHByLmZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cGluZ0V4cHIgPSB0aGlzLmV4cHJlc3Npb25zLmZpbmQoZXggPT4gZXguZmllbGROYW1lID09PSBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cGluZ0V4cHIgJiYgZ3JvdXBpbmdFeHByLmRpciAhPT0gc29ydEV4cHIuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nRXhwci5kaXIgPSBzb3J0RXhwci5kaXI7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbLi4udGhpcy5leHByZXNzaW9uc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZVJlb3JkZXIoZXZlbnQ6IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpcHNBcnJheSwgb3JpZ2luYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IG5ld0V4cHJlc3Npb25zID0gdGhpcy5nZXRSZW9yZGVyZWRFeHByZXNzaW9ucyhjaGlwc0FycmF5KTtcblxuICAgICAgICB0aGlzLmNoaXBFeHByZXNzaW9ucyA9IG5ld0V4cHJlc3Npb25zO1xuXG4gICAgICAgIC8vIFdoZW4gcmVvcmRlcmVkIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24sIHdlIGRvbid0IGhhdmUgYG9uTW92ZUVuZGAgZXZlbnQuXG4gICAgICAgIGlmIChvcmlnaW5hbEV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IG5ld0V4cHJlc3Npb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZU1vdmVFbmQoKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSB0aGlzLmNoaXBFeHByZXNzaW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ3JvdXBCeShleHByZXNzaW9uOiBJR3JvdXBpbmdFeHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IFsuLi50aGlzLmV4cHJlc3Npb25zXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXJHcm91cGluZyhuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IHRoaXMuZXhwcmVzc2lvbnMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5maWVsZE5hbWUgIT09IG5hbWUpO1xuICAgICAgICB0aGlzLmdyaWQuc29ydGluZ0V4cHJlc3Npb25zID0gdGhpcy5ncmlkLnNvcnRpbmdFeHByZXNzaW9ucy5maWx0ZXIoaXRlbSA9PiBpdGVtLmZpZWxkTmFtZSAhPT0gbmFtZSk7XG4gICAgICAgIHRoaXMuZ3JpZC5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBleHByZXNzaW9uc0NoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sdW1uc1Zpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNvbHVtbnNWaXNpYmlsaXR5KCkge1xuICAgICAgICBpZiAodGhpcy5ncm91cGluZ0RpZmZlciAmJiB0aGlzLmdyaWQuY29sdW1ucyAmJiAhdGhpcy5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmdyb3VwaW5nRGlmZmVyLmRpZmYodGhpcy5leHByZXNzaW9ucyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmJiB0aGlzLmdyaWQuY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gdGhpcy5oaWRlR3JvdXBlZENvbHVtbnM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZ2V0Q29sdW1uQnlOYW1lKHJlYy5pdGVtLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0Q29sdW1uc1Zpc2liaWxpdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5jb2x1bW5zLmxlbmd0aCA+IDAgJiYgIXRoaXMuZ3JpZC5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zLmZvckVhY2goKGV4cHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiPGlneC1jaGlwcy1hcmVhIChyZW9yZGVyKT1cImhhbmRsZVJlb3JkZXIoJGV2ZW50KVwiIChtb3ZlRW5kKT1cImhhbmRsZU1vdmVFbmQoKVwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGV4cHJlc3Npb24gb2YgY2hpcEV4cHJlc3Npb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgIDxpZ3gtY2hpcFxuICAgICAgICAgICAgW2lkXT1cImV4cHJlc3Npb24uZmllbGROYW1lXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCIoZXhwcmVzc2lvbi5maWVsZE5hbWUgfCBpZ3hHcm91cEJ5TWV0YTpncmlkKS50aXRsZVwiXG4gICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiXG4gICAgICAgICAgICBbcmVtb3ZhYmxlXT1cIihleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQpLmdyb3VwYWJsZVwiXG4gICAgICAgICAgICBbZHJhZ2dhYmxlXT1cIihleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQpLmdyb3VwYWJsZVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiIShleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQpLmdyb3VwYWJsZVwiXG4gICAgICAgICAgICAoa2V5RG93bik9XCJoYW5kbGVLZXlEb3duKCRldmVudC5vd25lci5pZCwgJGV2ZW50Lm9yaWdpbmFsRXZlbnQpXCJcbiAgICAgICAgICAgIChyZW1vdmUpPVwiY2xlYXJHcm91cGluZygkZXZlbnQub3duZXIuaWQpXCJcbiAgICAgICAgICAgIChjaGlwQ2xpY2spPVwiaGFuZGxlQ2xpY2soZXhwcmVzc2lvbi5maWVsZE5hbWUpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+e3sgKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZCkudGl0bGUgfX08L3NwYW4+XG4gICAgICAgICAgICA8aWd4LWljb24gaWd4U3VmZml4Pnt7IGV4cHJlc3Npb24uZGlyID09PSAxID8gJ2Fycm93X3Vwd2FyZCcgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbiAgICAgICAgPC9pZ3gtY2hpcD5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkLWdyb3VwYXJlYV9fY29ubmVjdG9yXCI+XG4gICAgICAgICAgICA8aWd4LWljb24gW2hpZGRlbl09XCIobGFzdCAmJiAhZHJvcEFyZWFWaXNpYmxlKVwiPmFycm93X2ZvcndhcmQ8L2lneC1pY29uPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPGRpdiBpZ3hHcm91cEFyZWFEcm9wIGNsYXNzPVwiaWd4LWRyb3AtYXJlYXt7IGRlbnNpdHkgIT09ICdjb21mb3J0YWJsZScgPyAnLS0nICsgZGVuc2l0eSA6ICcnfX1cIlxuICAgICAgICBbYXR0ci5ncmlkSWRdPVwiZ3JpZC5pZFwiXG4gICAgICAgIFtoaWRkZW5dPVwiIWRyb3BBcmVhVmlzaWJsZVwiXG4gICAgICAgIChpZ3hEcm9wKT1cIm9uRHJhZ0Ryb3AoJGV2ZW50KVwiXG4gICAgPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHJvcEFyZWFUZW1wbGF0ZSB8fCBkZWZhdWx0XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L2lneC1jaGlwcy1hcmVhPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHQ+XG4gICAgPGlneC1pY29uIGNsYXNzPVwiaWd4LWRyb3AtYXJlYV9faWNvblwiPmdyb3VwX3dvcms8L2lneC1pY29uPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWRyb3AtYXJlYV9fdGV4dFwiPnt7IGRyb3BBcmVhTWVzc2FnZSB9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG4iXX0=