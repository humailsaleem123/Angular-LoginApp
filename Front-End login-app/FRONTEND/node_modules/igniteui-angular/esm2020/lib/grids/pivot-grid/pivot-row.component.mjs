import { ChangeDetectionStrategy, Component, forwardRef, HostBinding, Inject, Input } from '@angular/core';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxRowDirective } from '../row.directive';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../selection/selection.service";
import * as i2 from "../cell.component";
import * as i3 from "@angular/common";
import * as i4 from "../../directives/for-of/for_of.directive";
import * as i5 from "../../checkbox/checkbox.component";
import * as i6 from "../common/pipes";
import * as i7 from "./pivot-grid.pipes";
const MINIMUM_COLUMN_WIDTH = 200;
export class IgxPivotRowComponent extends IgxRowDirective {
    constructor(grid, selectionService, element, cdr, resolver, viewRef) {
        super(grid, selectionService, element, cdr);
        this.grid = grid;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        this.resolver = resolver;
        this.viewRef = viewRef;
        /**
         * @hidden
         * @internal
         */
        this.disabled = false;
    }
    /**
     * @hidden
     */
    get selected() {
        let isSelected = false;
        for (let rowDim of this.data.dimensions) {
            const key = PivotUtil.getRecordKey(this.data, rowDim);
            if (this.selectionService.isPivotRowSelected(key)) {
                isSelected = true;
            }
        }
        return isSelected;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @internal
     */
    get addRowUI() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    get inEditMode() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    set pinned(_value) {
    }
    get pinned() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    delete() {
    }
    /**
     * @hidden
     * @internal
     */
    beginAddRow() {
    }
    /**
     * @hidden
     * @internal
     */
    update(_value) {
    }
    /**
     * @hidden
     * @internal
     */
    pin() {
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    unpin() {
        return false;
    }
    /**
    *  The pivot record data passed to the row component.
    *
    * ```typescript
    * // get the pivot row data for the first selected row
    * let selectedRowData = this.grid.selectedRows[0].data;
    * ```
    */
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    /**
     * @hidden
     * @internal
     */
    get pivotAggregationData() {
        const aggregations = this.data.aggregationValues;
        const obj = {};
        aggregations.forEach((value, key) => {
            obj[key] = value;
        });
        return obj;
    }
    getCellClass(col) {
        const values = this.grid.values;
        if (values.length === 1) {
            return values[0].styles;
        }
        const colName = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const measureName = colName[colName.length - 1];
        return values.find(v => v.member === measureName)?.styles;
    }
    isCellActive(visibleColumnIndex) {
        const nav = this.grid.navigation;
        const node = nav.activeNode;
        return node && Object.keys(node).length !== 0 ?
            !nav.isRowHeaderActive &&
                super.isCellActive(visibleColumnIndex) :
            false;
    }
    getColumnData(col) {
        const path = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const keyValueMap = new Map();
        const colDimensions = PivotUtil.flatten(this.grid.columnDimensions);
        for (const dim of colDimensions) {
            keyValueMap.set(dim.memberName, path.shift());
        }
        let pivotValue;
        if (this.grid.hasMultipleValues) {
            pivotValue = this.grid.values.find(x => x.member === path.shift());
        }
        else {
            pivotValue = this.grid.values ? this.grid.values[0] : undefined;
        }
        return {
            field: col.field,
            dimensions: this.grid.columnDimensions,
            dimensionValues: keyValueMap,
            value: pivotValue
        };
    }
}
IgxPivotRowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxPivotRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i1.IgxGridSelectionService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
IgxPivotRowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxPivotRowComponent, selector: "igx-pivot-row", inputs: { selected: "selected", data: "data" }, host: { properties: { "attr.aria-selected": "this.selected" } }, providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], usesInheritance: true, ngImport: i0, template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.width\" [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n", dependencies: [{ kind: "component", type: i2.IgxGridCellComponent, selector: "igx-grid-cell", inputs: ["column", "intRow", "row", "rowData", "columnData", "cellTemplate", "pinnedIndicator", "value", "formatter", "visibleColumnIndex", "cellSelectionMode", "lastSearchInfo", "lastPinned", "firstPinned", "editMode", "width", "active", "displayPinnedChip"] }, { kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i4.IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: i5.IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "pipe", type: i6.IgxGridNotGroupedPipe, name: "igxNotGrouped" }, { kind: "pipe", type: i6.IgxGridCellStylesPipe, name: "igxCellStyles" }, { kind: "pipe", type: i6.IgxGridDataMapperPipe, name: "dataMapper" }, { kind: "pipe", type: i6.IgxStringReplacePipe, name: "igxStringReplace" }, { kind: "pipe", type: i6.IgxGridTransactionStatePipe, name: "transactionState" }, { kind: "pipe", type: i7.IgxPivotGridCellStyleClassesPipe, name: "igxPivotCellStyleClasses" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxPivotRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row', providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n        [attr.aria-describedby]=\"gridID + '_' + col.field | igxStringReplace:'.':'_'\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.width\" [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i1.IgxGridSelectionService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }]; }, propDecorators: { selected: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.aria-selected']
            }], data: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXJvdy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBR1QsVUFBVSxFQUNWLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM3QixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUduRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7Ozs7Ozs7QUFHekMsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLENBQUM7QUFPakMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGVBQWU7SUFpQnJELFlBQ2tDLElBQW1CLEVBQzFDLGdCQUF5QyxFQUN6QyxPQUFnQyxFQUNoQyxHQUFzQixFQUNuQixRQUFrQyxFQUNsQyxPQUF5QjtRQUVuQyxLQUFLLENBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQVBkLFNBQUksR0FBSixJQUFJLENBQWU7UUFDMUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUF5QjtRQUN6QyxZQUFPLEdBQVAsT0FBTyxDQUF5QjtRQUNoQyxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUEwQjtRQUNsQyxZQUFPLEdBQVAsT0FBTyxDQUFrQjtRQWF2Qzs7O1dB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LENBQUMsS0FBSztZQUNoQixVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0I7WUFDdEMsZUFBZSxFQUFFLFdBQVc7WUFDNUIsS0FBSyxFQUFFLFVBQVU7U0FDcEIsQ0FBQztJQUNOLENBQUM7O2lIQTlLUSxvQkFBb0Isa0JBa0JqQixhQUFhO3FHQWxCaEIsb0JBQW9CLHlKQUZsQixDQUFDLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxpREN2QmxHLG84RUErQkE7MkZETmEsb0JBQW9CO2tCQU5oQyxTQUFTO3NDQUNXLHVCQUF1QixDQUFDLE1BQU0sWUFDckMsZUFBZSxhQUVkLENBQUMsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLHFCQUFxQixDQUFDLEVBQUUsQ0FBQzs7MEJBb0J6RixNQUFNOzJCQUFDLGFBQWE7aU5BWmQsUUFBUTtzQkFGbEIsS0FBSzs7c0JBQ0wsV0FBVzt1QkFBQyxvQkFBb0I7Z0JBOEd0QixJQUFJO3NCQURkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZHVtcFRydWNrIH0gZnJvbSAnQGlnbml0ZXVpL21hdGVyaWFsLWljb25zLWV4dGVuZGVkJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVBpdm90R3JpZENvbHVtbiwgSVBpdm90R3JpZFJlY29yZCB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcblxuXG5jb25zdCBNSU5JTVVNX0NPTFVNTl9XSURUSCA9IDIwMDtcbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHNlbGVjdG9yOiAnaWd4LXBpdm90LXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Bpdm90LXJvdy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hSb3dEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneFBpdm90Um93Q29tcG9uZW50KSB9XVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd0NvbXBvbmVudCBleHRlbmRzIElneFJvd0RpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWQnKVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJvd0RpbSBvZiB0aGlzLmRhdGEuZGltZW5zaW9ucykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gUGl2b3RVdGlsLmdldFJlY29yZEtleSh0aGlzLmRhdGEsIHJvd0RpbSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzUGl2b3RSb3dTZWxlY3RlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHVibGljIGdyaWQ6IFBpdm90R3JpZFR5cGUsXG4gICAgICAgIHB1YmxpYyBzZWxlY3Rpb25TZXJ2aWNlOiBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgcHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByb3RlY3RlZCB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGdyaWQsIHNlbGVjdGlvblNlcnZpY2UsIGVsZW1lbnQsIGNkcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmlld0luZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFkZFJvd1VJKCk6IGFueSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBpbkVkaXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgcGlubmVkKF92YWx1ZTogYm9vbGVhbikge1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGUoKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBiZWdpbkFkZFJvdygpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZShfdmFsdWU6IGFueSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgcGluKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyB1bnBpbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogIFRoZSBwaXZvdCByZWNvcmQgZGF0YSBwYXNzZWQgdG8gdGhlIHJvdyBjb21wb25lbnQuXG4gICAgKlxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogLy8gZ2V0IHRoZSBwaXZvdCByb3cgZGF0YSBmb3IgdGhlIGZpcnN0IHNlbGVjdGVkIHJvd1xuICAgICogbGV0IHNlbGVjdGVkUm93RGF0YSA9IHRoaXMuZ3JpZC5zZWxlY3RlZFJvd3NbMF0uZGF0YTtcbiAgICAqIGBgYFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGRhdGEoKTogSVBpdm90R3JpZFJlY29yZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZGF0YSh2OiBJUGl2b3RHcmlkUmVjb3JkKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBpdm90QWdncmVnYXRpb25EYXRhKCkge1xuICAgICAgICBjb25zdCBhZ2dyZWdhdGlvbnMgPSB0aGlzLmRhdGEuYWdncmVnYXRpb25WYWx1ZXM7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBhZ2dyZWdhdGlvbnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENlbGxDbGFzcyhjb2w6IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdyaWQudmFsdWVzO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1swXS5zdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sTmFtZSA9IGNvbC5maWVsZC5zcGxpdCh0aGlzLmdyaWQucGl2b3RLZXlzLmNvbHVtbkRpbWVuc2lvblNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVOYW1lID0gY29sTmFtZVtjb2xOYW1lLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmZpbmQodiA9PiB2Lm1lbWJlciA9PT0gbWVhc3VyZU5hbWUpPy5zdHlsZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGlzQ2VsbEFjdGl2ZSh2aXNpYmxlQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgY29uc3QgbmF2ID0gdGhpcy5ncmlkLm5hdmlnYXRpb25cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hdi5hY3RpdmVOb2RlO1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggIT09IDAgP1xuICAgICAgICAgICAgIW5hdi5pc1Jvd0hlYWRlckFjdGl2ZSAmJlxuICAgICAgICAgICAgc3VwZXIuaXNDZWxsQWN0aXZlKHZpc2libGVDb2x1bW5JbmRleCkgOlxuICAgICAgICAgICAgZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENvbHVtbkRhdGEoY29sOiBJZ3hDb2x1bW5Db21wb25lbnQpIDogSVBpdm90R3JpZENvbHVtbiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBjb2wuZmllbGQuc3BsaXQodGhpcy5ncmlkLnBpdm90S2V5cy5jb2x1bW5EaW1lbnNpb25TZXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBrZXlWYWx1ZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICAgIGNvbnN0IGNvbERpbWVuc2lvbnMgPSBQaXZvdFV0aWwuZmxhdHRlbih0aGlzLmdyaWQuY29sdW1uRGltZW5zaW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgZGltIG9mIGNvbERpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIGtleVZhbHVlTWFwLnNldChkaW0ubWVtYmVyTmFtZSwgcGF0aC5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGl2b3RWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5oYXNNdWx0aXBsZVZhbHVlcykge1xuICAgICAgICAgICAgcGl2b3RWYWx1ZSA9IHRoaXMuZ3JpZC52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBwYXRoLnNoaWZ0KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl2b3RWYWx1ZSA9IHRoaXMuZ3JpZC52YWx1ZXMgPyB0aGlzLmdyaWQudmFsdWVzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZDogY29sLmZpZWxkLFxuICAgICAgICAgICAgZGltZW5zaW9uczogdGhpcy5ncmlkLmNvbHVtbkRpbWVuc2lvbnMsXG4gICAgICAgICAgICBkaW1lbnNpb25WYWx1ZXM6IGtleVZhbHVlTWFwLFxuICAgICAgICAgICAgdmFsdWU6IHBpdm90VmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCI8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtY29sIFtpZ3hHcmlkRm9yT2ZdPVwidW5waW5uZWRDb2x1bW5zIHwgaWd4Tm90R3JvdXBlZFwiXG4gICAgW2lneEZvclNjcm9sbENvbnRhaW5lcl09XCJncmlkLnBhcmVudFZpcnREaXJcIiBsZXQtY29sSW5kZXg9XCJpbmRleFwiIFtpZ3hGb3JTaXplUHJvcE5hbWVdPSdcImNhbGNQaXhlbFdpZHRoXCInXG4gICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JDb250YWluZXJTaXplXT0nZ3JpZC51bnBpbm5lZFdpZHRoJ1xuICAgIFtpZ3hGb3JUcmFja0J5XT0nZ3JpZC50cmFja0NvbHVtbkNoYW5nZXMnICNpZ3hEaXJSZWY+XG4gICAgPGlneC1ncmlkLWNlbGwgI2NlbGwgY2xhc3M9XCJpZ3gtZ3JpZF9fdGQgaWd4LWdyaWRfX3RkLS1md1wiXG4gICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdGQtLWVkaXRlZF09XCJrZXkgfCB0cmFuc2FjdGlvblN0YXRlOmNvbC5maWVsZDpncmlkLnJvd0VkaXRhYmxlOmdyaWQudHJhbnNhY3Rpb25zOmdyaWQucGlwZVRyaWdnZXI6Z3JpZC5ncmlkQVBJLmNydWRTZXJ2aWNlLmNlbGw6Z3JpZC5ncmlkQVBJLmNydWRTZXJ2aWNlLnJvd1wiXG4gICAgICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiZ3JpZElEICsgJ18nICsgY29sLmZpZWxkIHwgaWd4U3RyaW5nUmVwbGFjZTonLic6J18nXCJcbiAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ZC0tbnVtYmVyXT1cImNvbC5kYXRhVHlwZSA9PT0gJ251bWJlcicgfHwgY29sLmRhdGFUeXBlID09PSAncGVyY2VudCcgfHwgY29sLmRhdGFUeXBlID09PSAnY3VycmVuY3knXCJcbiAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ZC0tYm9vbF09XCJjb2wuZGF0YVR5cGUgPT09ICdib29sZWFuJ1wiXG4gICAgICAgIFtuZ0NsYXNzXT1cInRoaXMuZ2V0Q2VsbENsYXNzKGNvbCkgfCBpZ3hQaXZvdENlbGxTdHlsZUNsYXNzZXM6ZGF0YVtjb2wuZmllbGRdOmRhdGE6Z2V0Q29sdW1uRGF0YShjb2wpOnZpZXdJbmRleDpncmlkLnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgW25nU3R5bGVdPVwiY29sLmNlbGxTdHlsZXMgfCBpZ3hDZWxsU3R5bGVzOnBpdm90QWdncmVnYXRpb25EYXRhW2NvbC5maWVsZF06cGl2b3RBZ2dyZWdhdGlvbkRhdGE6Y29sLmZpZWxkOnZpZXdJbmRleDpncmlkLnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgW2VkaXRNb2RlXT1cImNvbC5lZGl0YWJsZSAmJiB0aGlzLmdyaWQuY3J1ZFNlcnZpY2UudGFyZ2V0SW5FZGl0KGluZGV4LCBjb2wuaW5kZXgpXCIgW2NvbHVtbl09XCJjb2xcIlxuICAgICAgICBbZm9ybWF0dGVyXT1cImNvbC5mb3JtYXR0ZXJcIiBbaW50Um93XT1cInRoaXNcIiBbYWN0aXZlXT1cImlzQ2VsbEFjdGl2ZShjb2wudmlzaWJsZUluZGV4KVwiXG4gICAgICAgIFtzdHlsZS5taW4taGVpZ2h0LnB4XT1cImNlbGxIZWlnaHRcIiBbcm93RGF0YV09XCJkYXRhXCIgW2NvbHVtbkRhdGFdPSdnZXRDb2x1bW5EYXRhKGNvbCknXG4gICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sLndpZHRoXCIgW3N0eWxlLm1heC13aWR0aF09XCJjb2wud2lkdGhcIlxuICAgICAgICBbc3R5bGUuZmxleC1iYXNpc109XCJjb2wud2lkdGhcIiBbd2lkdGhdPVwiY29sLmdldENlbGxXaWR0aCgpXCIgW3Zpc2libGVDb2x1bW5JbmRleF09XCJjb2wudmlzaWJsZUluZGV4XCJcbiAgICAgICAgW3ZhbHVlXT1cInBpdm90QWdncmVnYXRpb25EYXRhW2NvbC5maWVsZF0gfCBkYXRhTWFwcGVyOmNvbC5maWVsZDpncmlkLnBpcGVUcmlnZ2VyOnBpdm90QWdncmVnYXRpb25EYXRhW2NvbC5maWVsZF06Y29sLmhhc05lc3RlZFBhdGhcIlxuICAgICAgICBbY2VsbFRlbXBsYXRlXT1cImNvbC5ib2R5VGVtcGxhdGVcIiBbbGFzdFNlYXJjaEluZm9dPVwiZ3JpZC5sYXN0U2VhcmNoSW5mb1wiXG4gICAgICAgIFtjZWxsU2VsZWN0aW9uTW9kZV09XCJncmlkLmNlbGxTZWxlY3Rpb25cIiBbZGlzcGxheVBpbm5lZENoaXBdPVwic2hvdWxkRGlzcGxheVBpbm5lZENoaXAoY29sLnZpc2libGVJbmRleClcIlxuICAgICAgICAocG9pbnRlcmRvd24pPVwiZ3JpZC5uYXZpZ2F0aW9uLmZvY3VzT3V0Um93SGVhZGVyKCRldmVudClcIj5cbiAgICA8L2lneC1ncmlkLWNlbGw+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI3Jvd1NlbGVjdG9yQmFzZVRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fY2J4LXBhZGRpbmdcIj5cbiAgICAgICAgPGlneC1jaGVja2JveCBbdGFiaW5kZXhdPVwiLTFcIiBbcmVhZG9ubHldPVwidHJ1ZVwiIFtjaGVja2VkXT1cInNlbGVjdGVkXCIgW2Rpc2FibGVSaXBwbGVdPVwidHJ1ZVwiIFtkaXNhYmxlZF09XCJkZWxldGVkXCJcbiAgICAgICAgICAgIFtkaXNhYmxlVHJhbnNpdGlvbnNdPVwiZ3JpZC5kaXNhYmxlVHJhbnNpdGlvbnNcIiBbYXJpYS1sYWJlbF09XCJyb3dDaGVja2JveEFyaWFMYWJlbFwiPlxuICAgICAgICA8L2lneC1jaGVja2JveD5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbiJdfQ==