import { CommonModule } from '@angular/common';
import { Component, Input, Output, EventEmitter, ContentChild, Directive, NgModule, TemplateRef, ContentChildren, HostBinding, Optional, Inject } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { growVerIn, growVerOut } from '../animations/grow';
import { IgxCheckboxModule } from '../checkbox/checkbox.component';
import { DisplayDensityBase, DisplayDensityToken } from '../core/displayDensity';
import { IgxExpansionPanelModule } from '../expansion-panel/public_api';
import { IgxIconModule } from '../icon/public_api';
import { IgxInputGroupModule } from '../input-group/public_api';
import { IgxProgressBarModule } from '../progressbar/progressbar.component';
import { IGX_TREE_COMPONENT, IgxTreeSelectionType } from './common';
import { IgxTreeNavigationService } from './tree-navigation.service';
import { IgxTreeNodeComponent, IgxTreeNodeLinkDirective } from './tree-node/tree-node.component';
import { IgxTreeSelectionService } from './tree-selection.service';
import { IgxTreeService } from './tree.service';
import * as i0 from "@angular/core";
import * as i1 from "./tree-navigation.service";
import * as i2 from "./tree-selection.service";
import * as i3 from "./tree.service";
/**
 * @hidden @internal
 * Used for templating the select marker of the tree
 */
export class IgxTreeSelectMarkerDirective {
}
IgxTreeSelectMarkerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeSelectMarkerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
IgxTreeSelectMarkerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.0", type: IgxTreeSelectMarkerDirective, selector: "[igxTreeSelectMarker]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeSelectMarkerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeSelectMarker]'
                }]
        }] });
/**
 * @hidden @internal
 * Used for templating the expand indicator of the tree
 */
export class IgxTreeExpandIndicatorDirective {
}
IgxTreeExpandIndicatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeExpandIndicatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
IgxTreeExpandIndicatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.0", type: IgxTreeExpandIndicatorDirective, selector: "[igxTreeExpandIndicator]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeExpandIndicatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeExpandIndicator]'
                }]
        }] });
/**
 * IgxTreeComponent allows a developer to show a set of nodes in a hierarchical fashion.
 *
 * @igxModule IgxTreeModule
 * @igxKeywords tree
 * @igxTheme igx-tree-theme
 * @igxGroup Grids & Lists
 *
 * @remark
 * The Angular Tree Component allows users to represent hierarchical data in a tree-view structure,
 * maintaining parent-child relationships, as well as to define static tree-view structure without a corresponding data model.
 * Its primary purpose is to allow end-users to visualize and navigate within hierarchical data structures.
 * The Ignite UI for Angular Tree Component also provides load on demand capabilities, item activation,
 * bi-state and cascading selection of items through built-in checkboxes, built-in keyboard navigation and more.
 *
 * @example
 * ```html
 * <igx-tree>
 *   <igx-tree-node>
 *      I am a parent node 1
 *      <igx-tree-node>
 *          I am a child node 1
 *      </igx-tree-node>
 *      ...
 *   </igx-tree-node>
 *	 ...
 * </igx-tree>
 * ```
 */
export class IgxTreeComponent extends DisplayDensityBase {
    constructor(navService, selectionService, treeService, element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.navService = navService;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this.cssClass = 'igx-tree';
        /** Get/Set how the tree should handle branch expansion.
         * If set to `true`, only a single branch can be expanded at a time, collapsing all others
         *
         * ```html
         * <igx-tree [singleBranchExpand]="true">
         * ...
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const tree: IgxTree = this.tree;
         * this.tree.singleBranchExpand = false;
         * ```
         */
        this.singleBranchExpand = false;
        /** Get/Set the animation settings that branches should use when expanding/collpasing.
         *
         * ```html
         * <igx-tree [animationSettings]="customAnimationSettings">
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const animationSettings: ToggleAnimationSettings = {
         *      openAnimation: growVerIn,
         *      closeAnimation: growVerOut
         * };
         *
         * this.tree.animationSettings = animationSettings;
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /** Emitted when the node selection is changed through interaction
         *
         * ```html
         * <igx-tree (nodeSelection)="handleNodeSelection($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeSelection(event: ITreeNodeSelectionEvent) {
         *  const newSelection: IgxTreeNode<any>[] = event.newSelection;
         *  const added: IgxTreeNode<any>[] = event.added;
         *  console.log("New selection will be: ", newSelection);
         *  console.log("Added nodes: ", event.added);
         * }
         *```
         */
        this.nodeSelection = new EventEmitter();
        /** Emitted when a node is expanding, before it finishes
         *
         * ```html
         * <igx-tree (nodeExpanding)="handleNodeExpanding($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanding(event: ITreeNodeTogglingEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  if (expandedNode.disabled) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeExpanding = new EventEmitter();
        /** Emitted when a node is expanded, after it finishes
         *
         * ```html
         * <igx-tree (nodeExpanded)="handleNodeExpanded($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanded(event: ITreeNodeToggledEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is expanded: ", expandedNode.data);
         * }
         *```
         */
        this.nodeExpanded = new EventEmitter();
        /** Emitted when a node is collapsing, before it finishes
         *
         * ```html
         * <igx-tree (nodeCollapsing)="handleNodeCollapsing($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeCollapsing(event: ITreeNodeTogglingEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  if (collapsedNode.alwaysOpen) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeCollapsing = new EventEmitter();
        /** Emitted when a node is collapsed, after it finishes
         *
         * @example
         * ```html
         * <igx-tree (nodeCollapsed)="handleNodeCollapsed($event)">
         * </igx-tree>
         * ```
         * ```typescript
         * public handleNodeCollapsed(event: ITreeNodeToggledEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is collapsed: ", collapsedNode.data);
         * }
         * ```
         */
        this.nodeCollapsed = new EventEmitter();
        /**
         * Emitted when the active node is changed.
         *
         * @example
         * ```
         * <igx-tree (activeNodeChanged)="activeNodeChanged($event)"></igx-tree>
         * ```
         */
        this.activeNodeChanged = new EventEmitter();
        /** @hidden @internal */
        this.disabledChange = new EventEmitter();
        /**
         * Emitted when the active node is set through API
         *
         * @hidden @internal
         */
        this.activeNodeBindingChange = new EventEmitter();
        /** @hidden @internal */
        this.forceSelect = [];
        this._selection = IgxTreeSelectionType.None;
        this.destroy$ = new Subject();
        this.unsubChildren$ = new Subject();
        this._comparer = (data, node) => node.data === data;
        this.selectionService.register(this);
        this.treeService.register(this);
        this.navService.register(this);
    }
    /**
     * Gets/Sets tree selection mode
     *
     * @remarks
     * By default the tree selection mode is 'None'
     * @param selectionMode: IgxTreeSelectionType
     */
    get selection() {
        return this._selection;
    }
    set selection(selectionMode) {
        this._selection = selectionMode;
        this.selectionService.clearNodesSelection();
    }
    /**
     * Returns all **root level** nodes
     *
     * ```typescript
     * const tree: IgxTree = this.tree;
     * const rootNodes: IgxTreeNodeComponent<any>[] = tree.rootNodes;
     * ```
     */
    get rootNodes() {
        return this.nodes?.filter(node => node.level === 0);
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Expands all of the passed nodes.
     * If no nodes are passed, expands ALL nodes
     *
     * @param nodes nodes to be expanded
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.expandable);
     * tree.expandAll(nodes);
     * ```
     */
    expandAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = true);
    }
    /**
     * Collapses all of the passed nodes.
     * If no nodes are passed, collapses ALL nodes
     *
     * @param nodes nodes to be collapsed
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.collapsible);
     * tree.collapseAll(nodes);
     * ```
     */
    collapseAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = false);
    }
    /**
     * Deselect all nodes if the nodes collection is empty. Otherwise, deselect the nodes in the nodes collection.
     *
     * @example
     * ```typescript
     *  const arr = [
     *      this.tree.nodes.toArray()[0],
     *      this.tree.nodes.toArray()[1]
     *  ];
     *  this.tree.deselectAll(arr);
     * ```
     * @param nodes: IgxTreeNodeComponent<any>[]
     */
    deselectAll(nodes) {
        this.selectionService.deselectNodesWithNoEvent(nodes);
    }
    /**
     * Returns all of the nodes that match the passed searchTerm.
     * Accepts a custom comparer function for evaluating the search term against the nodes.
     *
     * @remark
     * Default search compares the passed `searchTerm` against the node's `data` Input.
     * When using `findNodes` w/o a `comparer`, make sure all nodes have `data` passed.
     *
     * @param searchTerm The data of the searched node
     * @param comparer A custom comparer function that evaluates the passed `searchTerm` against all nodes.
     * @returns Array of nodes that match the search. `null` if no nodes are found.
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node *ngFor="let node of data" [data]="node">
     *          {{ node.label }}
     *     </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const matchedNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(searchTerm: data[5]);
     * ```
     *
     * Using a custom comparer
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const comparer: IgxTreeSearchResolver = (data: any, node: IgxTreeNode<DataEntry>) {
     *      return node.data.index % 2 === 0;
     * }
     * const evenIndexNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(null, comparer);
     * ```
     */
    findNodes(searchTerm, comparer) {
        const compareFunc = comparer || this._comparer;
        const results = this.nodes.filter(node => compareFunc(searchTerm, node));
        return results?.length === 0 ? null : results;
    }
    /** @hidden @internal */
    handleKeydown(event) {
        this.navService.handleKeydown(event);
    }
    /** @hidden @internal */
    ngOnInit() {
        super.ngOnInit();
        this.disabledChange.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            this.navService.update_disabled_cache(e);
        });
        this.activeNodeBindingChange.pipe(takeUntil(this.destroy$)).subscribe((node) => {
            this.expandToNode(this.navService.activeNode);
            this.scrollNodeIntoView(node?.header?.nativeElement);
        });
        this.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
            requestAnimationFrame(() => {
                this.scrollNodeIntoView(this.navService.activeNode?.header.nativeElement);
            });
        });
        this.subToCollapsing();
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        this.nodes.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.subToChanges();
        });
        this.scrollNodeIntoView(this.navService.activeNode?.header?.nativeElement);
        this.subToChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.unsubChildren$.next();
        this.unsubChildren$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    expandToNode(node) {
        if (node && node.parentNode) {
            node.path.forEach(n => {
                if (n !== node && !n.expanded) {
                    n.expanded = true;
                }
            });
        }
    }
    subToCollapsing() {
        this.nodeCollapsing.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, false);
        });
        this.nodeExpanding.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, true);
        });
    }
    subToChanges() {
        this.unsubChildren$.next();
        const toBeSelected = [...this.forceSelect];
        requestAnimationFrame(() => {
            this.selectionService.selectNodesWithNoEvent(toBeSelected);
        });
        this.forceSelect = [];
        this.nodes.forEach(node => {
            node.expandedChange.pipe(takeUntil(this.unsubChildren$)).subscribe(nodeState => {
                this.navService.update_visible_cache(node, nodeState);
            });
            node.closeAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
            node.openAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
        });
        this.navService.init_invisible_cache();
    }
    scrollNodeIntoView(el) {
        if (!el) {
            return;
        }
        const nodeRect = el.getBoundingClientRect();
        const treeRect = this.nativeElement.getBoundingClientRect();
        const topOffset = treeRect.top > nodeRect.top ? nodeRect.top - treeRect.top : 0;
        const bottomOffset = treeRect.bottom < nodeRect.bottom ? nodeRect.bottom - treeRect.bottom : 0;
        const shouldScroll = !!topOffset || !!bottomOffset;
        if (shouldScroll && this.nativeElement.scrollHeight > this.nativeElement.clientHeight) {
            // this.nativeElement.scrollTop = nodeRect.y - treeRect.y - nodeRect.height;
            this.nativeElement.scrollTop =
                this.nativeElement.scrollTop + bottomOffset + topOffset + (topOffset ? -1 : +1) * nodeRect.height;
        }
    }
}
IgxTreeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeComponent, deps: [{ token: i1.IgxTreeNavigationService }, { token: i2.IgxTreeSelectionService }, { token: i3.IgxTreeService }, { token: i0.ElementRef }, { token: DisplayDensityToken, optional: true }], target: i0.ɵɵFactoryTarget.Component });
IgxTreeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxTreeComponent, selector: "igx-tree", inputs: { selection: "selection", singleBranchExpand: "singleBranchExpand", animationSettings: "animationSettings" }, outputs: { nodeSelection: "nodeSelection", nodeExpanding: "nodeExpanding", nodeExpanded: "nodeExpanded", nodeCollapsing: "nodeCollapsing", nodeCollapsed: "nodeCollapsed", activeNodeChanged: "activeNodeChanged" }, host: { properties: { "class.igx-tree": "this.cssClass" } }, providers: [
        IgxTreeService,
        IgxTreeSelectionService,
        IgxTreeNavigationService,
        { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
    ], queries: [{ propertyName: "expandIndicator", first: true, predicate: IgxTreeExpandIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "nodes", predicate: IgxTreeNodeComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree', providers: [
                        IgxTreeService,
                        IgxTreeSelectionService,
                        IgxTreeNavigationService,
                        { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
                    ], template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.IgxTreeNavigationService }, { type: i2.IgxTreeSelectionService }, { type: i3.IgxTreeService }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DisplayDensityToken]
                }] }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-tree']
            }], selection: [{
                type: Input
            }], singleBranchExpand: [{
                type: Input
            }], animationSettings: [{
                type: Input
            }], nodeSelection: [{
                type: Output
            }], nodeExpanding: [{
                type: Output
            }], nodeExpanded: [{
                type: Output
            }], nodeCollapsing: [{
                type: Output
            }], nodeCollapsed: [{
                type: Output
            }], activeNodeChanged: [{
                type: Output
            }], expandIndicator: [{
                type: ContentChild,
                args: [IgxTreeExpandIndicatorDirective, { read: TemplateRef }]
            }], nodes: [{
                type: ContentChildren,
                args: [IgxTreeNodeComponent, { descendants: true }]
            }] } });
/**
 * @hidden
 *
 * NgModule defining the components and directives needed for `igx-tree`
 */
export class IgxTreeModule {
}
IgxTreeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IgxTreeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeModule, declarations: [IgxTreeSelectMarkerDirective, IgxTreeExpandIndicatorDirective, IgxTreeNodeLinkDirective, IgxTreeComponent, IgxTreeNodeComponent], imports: [CommonModule,
        FormsModule,
        IgxIconModule,
        IgxInputGroupModule,
        IgxCheckboxModule,
        IgxProgressBarModule], exports: [IgxTreeSelectMarkerDirective, IgxTreeExpandIndicatorDirective, IgxTreeNodeLinkDirective, IgxTreeComponent, IgxTreeNodeComponent,
        IgxIconModule,
        IgxInputGroupModule,
        IgxCheckboxModule,
        IgxExpansionPanelModule] });
IgxTreeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeModule, imports: [CommonModule,
        FormsModule,
        IgxIconModule,
        IgxInputGroupModule,
        IgxCheckboxModule,
        IgxProgressBarModule, IgxIconModule,
        IgxInputGroupModule,
        IgxCheckboxModule,
        IgxExpansionPanelModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxTreeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        IgxTreeSelectMarkerDirective,
                        IgxTreeExpandIndicatorDirective,
                        IgxTreeNodeLinkDirective,
                        IgxTreeComponent,
                        IgxTreeNodeComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxIconModule,
                        IgxInputGroupModule,
                        IgxCheckboxModule,
                        IgxProgressBarModule
                    ],
                    exports: [
                        IgxTreeSelectMarkerDirective,
                        IgxTreeExpandIndicatorDirective,
                        IgxTreeNodeLinkDirective,
                        IgxTreeComponent,
                        IgxTreeNodeComponent,
                        IgxIconModule,
                        IgxInputGroupModule,
                        IgxCheckboxModule,
                        IgxExpansionPanelModule
                    ]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdHJlZS90cmVlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFDSCxTQUFTLEVBQWEsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFDMUUsUUFBUSxFQUFFLFdBQVcsRUFBeUIsZUFBZSxFQUFhLFdBQVcsRUFBYyxRQUFRLEVBQUUsTUFBTSxFQUN0SCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNuRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQTBCLE1BQU0sd0JBQXdCLENBQUM7QUFDekcsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FB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MkdBR2xCLGFBQWEsWUFuQmxCLFlBQVk7UUFDWixXQUFXO1FBQ1gsYUFBYTtRQUNiLG1CQUFtQjtRQUNuQixpQkFBaUI7UUFDakIsb0JBQW9CLEVBUXBCLGFBQWE7UUFDYixtQkFBbUI7UUFDbkIsaUJBQWlCO1FBQ2pCLHVCQUF1QjsyRkFHbEIsYUFBYTtrQkE1QnpCLFFBQVE7bUJBQUM7b0JBQ04sWUFBWSxFQUFFO3dCQUNWLDRCQUE0Qjt3QkFDNUIsK0JBQStCO3dCQUMvQix3QkFBd0I7d0JBQ3hCLGdCQUFnQjt3QkFDaEIsb0JBQW9CO3FCQUN2QjtvQkFDRCxPQUFPLEVBQUU7d0JBQ0wsWUFBWTt3QkFDWixXQUFXO3dCQUNYLGFBQWE7d0JBQ2IsbUJBQW1CO3dCQUNuQixpQkFBaUI7d0JBQ2pCLG9CQUFvQjtxQkFDdkI7b0JBQ0QsT0FBTyxFQUFFO3dCQUNMLDRCQUE0Qjt3QkFDNUIsK0JBQStCO3dCQUMvQix3QkFBd0I7d0JBQ3hCLGdCQUFnQjt3QkFDaEIsb0JBQW9CO3dCQUNwQixhQUFhO3dCQUNiLG1CQUFtQjt3QkFDbkIsaUJBQWlCO3dCQUNqQix1QkFBdUI7cUJBQzFCO2lCQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBRdWVyeUxpc3QsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBEaXJlY3RpdmUsXG4gICAgTmdNb2R1bGUsIFRlbXBsYXRlUmVmLCBPbkluaXQsIEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgT25EZXN0cm95LCBIb3N0QmluZGluZywgRWxlbWVudFJlZiwgT3B0aW9uYWwsIEluamVjdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnLi4vYW5pbWF0aW9ucy9ncm93JztcbmltcG9ydCB7IElneENoZWNrYm94TW9kdWxlIH0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5QmFzZSwgRGlzcGxheURlbnNpdHlUb2tlbiwgSURpc3BsYXlEZW5zaXR5T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUvZGlzcGxheURlbnNpdHknO1xuaW1wb3J0IHsgSWd4RXhwYW5zaW9uUGFuZWxNb2R1bGUgfSBmcm9tICcuLi9leHBhbnNpb24tcGFuZWwvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uL2V4cGFuc2lvbi1wYW5lbC90b2dnbGUtYW5pbWF0aW9uLWNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9wdWJsaWNfYXBpJztcbmltcG9ydCB7IElneElucHV0R3JvdXBNb2R1bGUgfSBmcm9tICcuLi9pbnB1dC1ncm91cC9wdWJsaWNfYXBpJztcbmltcG9ydCB7IElneFByb2dyZXNzQmFyTW9kdWxlIH0gZnJvbSAnLi4vcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgSUdYX1RSRUVfQ09NUE9ORU5ULCBJZ3hUcmVlU2VsZWN0aW9uVHlwZSwgSWd4VHJlZSwgSVRyZWVOb2RlVG9nZ2xlZEV2ZW50QXJncyxcbiAgICBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncywgSVRyZWVOb2RlU2VsZWN0aW9uRXZlbnQsIElneFRyZWVOb2RlLCBJZ3hUcmVlU2VhcmNoUmVzb2x2ZXJcbn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgSWd4VHJlZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmVlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlTm9kZUNvbXBvbmVudCwgSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlIH0gZnJvbSAnLi90cmVlLW5vZGUvdHJlZS1ub2RlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vdHJlZS1zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VydmljZSB9IGZyb20gJy4vdHJlZS5zZXJ2aWNlJztcblxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogVXNlZCBmb3IgdGVtcGxhdGluZyB0aGUgc2VsZWN0IG1hcmtlciBvZiB0aGUgdHJlZVxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hUcmVlU2VsZWN0TWFya2VyXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZVNlbGVjdE1hcmtlckRpcmVjdGl2ZSB7XG59XG5cbi8qKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqIFVzZWQgZm9yIHRlbXBsYXRpbmcgdGhlIGV4cGFuZCBpbmRpY2F0b3Igb2YgdGhlIHRyZWVcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4VHJlZUV4cGFuZEluZGljYXRvcl0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVFeHBhbmRJbmRpY2F0b3JEaXJlY3RpdmUge1xufVxuXG4vKipcbiAqIElneFRyZWVDb21wb25lbnQgYWxsb3dzIGEgZGV2ZWxvcGVyIHRvIHNob3cgYSBzZXQgb2Ygbm9kZXMgaW4gYSBoaWVyYXJjaGljYWwgZmFzaGlvbi5cbiAqXG4gKiBAaWd4TW9kdWxlIElneFRyZWVNb2R1bGVcbiAqIEBpZ3hLZXl3b3JkcyB0cmVlXG4gKiBAaWd4VGhlbWUgaWd4LXRyZWUtdGhlbWVcbiAqIEBpZ3hHcm91cCBHcmlkcyAmIExpc3RzXG4gKlxuICogQHJlbWFya1xuICogVGhlIEFuZ3VsYXIgVHJlZSBDb21wb25lbnQgYWxsb3dzIHVzZXJzIHRvIHJlcHJlc2VudCBoaWVyYXJjaGljYWwgZGF0YSBpbiBhIHRyZWUtdmlldyBzdHJ1Y3R1cmUsIFxuICogbWFpbnRhaW5pbmcgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHMsIGFzIHdlbGwgYXMgdG8gZGVmaW5lIHN0YXRpYyB0cmVlLXZpZXcgc3RydWN0dXJlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGRhdGEgbW9kZWwuIFxuICogSXRzIHByaW1hcnkgcHVycG9zZSBpcyB0byBhbGxvdyBlbmQtdXNlcnMgdG8gdmlzdWFsaXplIGFuZCBuYXZpZ2F0ZSB3aXRoaW4gaGllcmFyY2hpY2FsIGRhdGEgc3RydWN0dXJlcy4gXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFRyZWUgQ29tcG9uZW50IGFsc28gcHJvdmlkZXMgbG9hZCBvbiBkZW1hbmQgY2FwYWJpbGl0aWVzLCBpdGVtIGFjdGl2YXRpb24sIFxuICogYmktc3RhdGUgYW5kIGNhc2NhZGluZyBzZWxlY3Rpb24gb2YgaXRlbXMgdGhyb3VnaCBidWlsdC1pbiBjaGVja2JveGVzLCBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBtb3JlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXRyZWU+XG4gKiAgIDxpZ3gtdHJlZS1ub2RlPlxuICogICAgICBJIGFtIGEgcGFyZW50IG5vZGUgMVxuICogICAgICA8aWd4LXRyZWUtbm9kZT5cbiAqICAgICAgICAgIEkgYW0gYSBjaGlsZCBub2RlIDFcbiAqICAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICogICAgICAuLi5cbiAqICAgPC9pZ3gtdHJlZS1ub2RlPlxuICpcdCAuLi5cbiAqIDwvaWd4LXRyZWU+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdHJlZScsXG4gICAgdGVtcGxhdGVVcmw6ICd0cmVlLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4VHJlZVNlcnZpY2UsXG4gICAgICAgIElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX1RSRUVfQ09NUE9ORU5ULCB1c2VFeGlzdGluZzogSWd4VHJlZUNvbXBvbmVudCB9LFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUNvbXBvbmVudCBleHRlbmRzIERpc3BsYXlEZW5zaXR5QmFzZSBpbXBsZW1lbnRzIElneFRyZWUsIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRyZWUnKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtdHJlZSc7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdHJlZSBzZWxlY3Rpb24gbW9kZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBCeSBkZWZhdWx0IHRoZSB0cmVlIHNlbGVjdGlvbiBtb2RlIGlzICdOb25lJ1xuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25Nb2RlOiBJZ3hUcmVlU2VsZWN0aW9uVHlwZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzZWxlY3Rpb24oc2VsZWN0aW9uTW9kZTogSWd4VHJlZVNlbGVjdGlvblR5cGUpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFyTm9kZXNTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvKiogR2V0L1NldCBob3cgdGhlIHRyZWUgc2hvdWxkIGhhbmRsZSBicmFuY2ggZXhwYW5zaW9uLlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIG9ubHkgYSBzaW5nbGUgYnJhbmNoIGNhbiBiZSBleHBhbmRlZCBhdCBhIHRpbWUsIGNvbGxhcHNpbmcgYWxsIG90aGVyc1xuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSBbc2luZ2xlQnJhbmNoRXhwYW5kXT1cInRydWVcIj5cbiAgICAgKiAuLi5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRyZWU6IElneFRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICogdGhpcy50cmVlLnNpbmdsZUJyYW5jaEV4cGFuZCA9IGZhbHNlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNpbmdsZUJyYW5jaEV4cGFuZCA9IGZhbHNlO1xuXG4gICAgLyoqIEdldC9TZXQgdGhlIGFuaW1hdGlvbiBzZXR0aW5ncyB0aGF0IGJyYW5jaGVzIHNob3VsZCB1c2Ugd2hlbiBleHBhbmRpbmcvY29sbHBhc2luZy5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgW2FuaW1hdGlvblNldHRpbmdzXT1cImN1c3RvbUFuaW1hdGlvblNldHRpbmdzXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBhbmltYXRpb25TZXR0aW5nczogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3MgPSB7XG4gICAgICogICAgICBvcGVuQW5pbWF0aW9uOiBncm93VmVySW4sXG4gICAgICogICAgICBjbG9zZUFuaW1hdGlvbjogZ3Jvd1Zlck91dFxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB0aGlzLnRyZWUuYW5pbWF0aW9uU2V0dGluZ3MgPSBhbmltYXRpb25TZXR0aW5ncztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBhbmltYXRpb25TZXR0aW5nczogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3MgPSB7XG4gICAgICAgIG9wZW5BbmltYXRpb246IGdyb3dWZXJJbixcbiAgICAgICAgY2xvc2VBbmltYXRpb246IGdyb3dWZXJPdXRcbiAgICB9O1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgbm9kZSBzZWxlY3Rpb24gaXMgY2hhbmdlZCB0aHJvdWdoIGludGVyYWN0aW9uXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIChub2RlU2VsZWN0aW9uKT1cImhhbmRsZU5vZGVTZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlTm9kZVNlbGVjdGlvbihldmVudDogSVRyZWVOb2RlU2VsZWN0aW9uRXZlbnQpIHtcbiAgICAgKiAgY29uc3QgbmV3U2VsZWN0aW9uOiBJZ3hUcmVlTm9kZTxhbnk+W10gPSBldmVudC5uZXdTZWxlY3Rpb247XG4gICAgICogIGNvbnN0IGFkZGVkOiBJZ3hUcmVlTm9kZTxhbnk+W10gPSBldmVudC5hZGRlZDtcbiAgICAgKiAgY29uc29sZS5sb2coXCJOZXcgc2VsZWN0aW9uIHdpbGwgYmU6IFwiLCBuZXdTZWxlY3Rpb24pO1xuICAgICAqICBjb25zb2xlLmxvZyhcIkFkZGVkIG5vZGVzOiBcIiwgZXZlbnQuYWRkZWQpO1xuICAgICAqIH1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBub2RlU2VsZWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcjxJVHJlZU5vZGVTZWxlY3Rpb25FdmVudD4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBub2RlIGlzIGV4cGFuZGluZywgYmVmb3JlIGl0IGZpbmlzaGVzXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIChub2RlRXhwYW5kaW5nKT1cImhhbmRsZU5vZGVFeHBhbmRpbmcoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlTm9kZUV4cGFuZGluZyhldmVudDogSVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3MpIHtcbiAgICAgKiAgY29uc3QgZXhwYW5kZWROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gZXZlbnQubm9kZTtcbiAgICAgKiAgaWYgKGV4cGFuZGVkTm9kZS5kaXNhYmxlZCkge1xuICAgICAqICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgKiAgfVxuICAgICAqIH1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBub2RlRXhwYW5kaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncz4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBub2RlIGlzIGV4cGFuZGVkLCBhZnRlciBpdCBmaW5pc2hlc1xuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSAobm9kZUV4cGFuZGVkKT1cImhhbmRsZU5vZGVFeHBhbmRlZCgkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVOb2RlRXhwYW5kZWQoZXZlbnQ6IElUcmVlTm9kZVRvZ2dsZWRFdmVudEFyZ3MpIHtcbiAgICAgKiAgY29uc3QgZXhwYW5kZWROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gZXZlbnQubm9kZTtcbiAgICAgKiAgY29uc29sZS5sb2coXCJOb2RlIGlzIGV4cGFuZGVkOiBcIiwgZXhwYW5kZWROb2RlLmRhdGEpO1xuICAgICAqIH1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBub2RlRXhwYW5kZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElUcmVlTm9kZVRvZ2dsZWRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgbm9kZSBpcyBjb2xsYXBzaW5nLCBiZWZvcmUgaXQgZmluaXNoZXNcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgKG5vZGVDb2xsYXBzaW5nKT1cImhhbmRsZU5vZGVDb2xsYXBzaW5nKCRldmVudClcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGhhbmRsZU5vZGVDb2xsYXBzaW5nKGV2ZW50OiBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncykge1xuICAgICAqICBjb25zdCBjb2xsYXBzZWROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gZXZlbnQubm9kZTtcbiAgICAgKiAgaWYgKGNvbGxhcHNlZE5vZGUuYWx3YXlzT3Blbikge1xuICAgICAqICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgKiAgfVxuICAgICAqIH1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBub2RlQ29sbGFwc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgbm9kZSBpcyBjb2xsYXBzZWQsIGFmdGVyIGl0IGZpbmlzaGVzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgKG5vZGVDb2xsYXBzZWQpPVwiaGFuZGxlTm9kZUNvbGxhcHNlZCgkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGhhbmRsZU5vZGVDb2xsYXBzZWQoZXZlbnQ6IElUcmVlTm9kZVRvZ2dsZWRFdmVudEFyZ3MpIHtcbiAgICAgKiAgY29uc3QgY29sbGFwc2VkTm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IGV2ZW50Lm5vZGU7XG4gICAgICogIGNvbnNvbGUubG9nKFwiTm9kZSBpcyBjb2xsYXBzZWQ6IFwiLCBjb2xsYXBzZWROb2RlLmRhdGEpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbm9kZUNvbGxhcHNlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVRyZWVOb2RlVG9nZ2xlZEV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIG5vZGUgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogPGlneC10cmVlIChhY3RpdmVOb2RlQ2hhbmdlZCk9XCJhY3RpdmVOb2RlQ2hhbmdlZCgkZXZlbnQpXCI+PC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYWN0aXZlTm9kZUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElneFRyZWVOb2RlPGFueT4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSB0ZW1wbGF0ZSB0byBiZSB1c2VkIGZvciB0aGUgZXhwYW5kIGluZGljYXRvciBvZiBub2Rlc1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogIDxuZy10ZW1wbGF0ZSBpZ3hUcmVlRXhwYW5kSW5kaWNhdG9yIGxldC1leHBhbmRlZD5cbiAgICAgKiAgICAgIDxpZ3gtaWNvbj57eyBleHBhbmRlZCA/IFwiY2xvc2VfZnVsbHNjcmVlblwiOiBcIm9wZW5faW5fZnVsbFwifX08L2lneC1pY29uPlxuICAgICAqICA8L25nLXRlbXBsYXRlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hUcmVlRXhwYW5kSW5kaWNhdG9yRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgcHVibGljIGV4cGFuZEluZGljYXRvcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4VHJlZU5vZGVDb21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwdWJsaWMgbm9kZXM6IFF1ZXJ5TGlzdDxJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+PjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBkaXNhYmxlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4VHJlZU5vZGU8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsICoqcm9vdCBsZXZlbCoqIG5vZGVzXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHJlZTogSWd4VHJlZSA9IHRoaXMudHJlZTtcbiAgICAgKiBjb25zdCByb290Tm9kZXM6IElneFRyZWVOb2RlQ29tcG9uZW50PGFueT5bXSA9IHRyZWUucm9vdE5vZGVzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm9vdE5vZGVzKCk6IElneFRyZWVOb2RlQ29tcG9uZW50PGFueT5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzPy5maWx0ZXIobm9kZSA9PiBub2RlLmxldmVsID09PSAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGFjdGl2ZSBub2RlIGlzIHNldCB0aHJvdWdoIEFQSVxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYWN0aXZlTm9kZUJpbmRpbmdDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElneFRyZWVOb2RlPGFueT4+KCk7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZm9yY2VTZWxlY3QgPSBbXTtcblxuICAgIHByaXZhdGUgX3NlbGVjdGlvbjogSWd4VHJlZVNlbGVjdGlvblR5cGUgPSBJZ3hUcmVlU2VsZWN0aW9uVHlwZS5Ob25lO1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHByaXZhdGUgdW5zdWJDaGlsZHJlbiQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgbmF2U2VydmljZTogSWd4VHJlZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHNlbGVjdGlvblNlcnZpY2U6IElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRyZWVTZXJ2aWNlOiBJZ3hUcmVlU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChEaXNwbGF5RGVuc2l0eVRva2VuKSBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5T3B0aW9ucz86IElEaXNwbGF5RGVuc2l0eU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoX2Rpc3BsYXlEZW5zaXR5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy50cmVlU2VydmljZS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIG9mIHRoZSBwYXNzZWQgbm9kZXMuXG4gICAgICogSWYgbm8gbm9kZXMgYXJlIHBhc3NlZCwgZXhwYW5kcyBBTEwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlcyBub2RlcyB0byBiZSBleHBhbmRlZFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhcmdldE5vZGVzOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2Rlcyh0cnVlLCAoX2RhdGE6IGFueSwgbm9kZTogSWd4VHJlZU5vZGU8YW55PikgPT4gbm9kZS5kYXRhLmV4cGFuZGFibGUpO1xuICAgICAqIHRyZWUuZXhwYW5kQWxsKG5vZGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwYW5kQWxsKG5vZGVzPzogSWd4VHJlZU5vZGU8YW55PltdKSB7XG4gICAgICAgIG5vZGVzID0gbm9kZXMgfHwgdGhpcy5ub2Rlcy50b0FycmF5KCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZSA9PiBlLmV4cGFuZGVkID0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCBvZiB0aGUgcGFzc2VkIG5vZGVzLlxuICAgICAqIElmIG5vIG5vZGVzIGFyZSBwYXNzZWQsIGNvbGxhcHNlcyBBTEwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlcyBub2RlcyB0byBiZSBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0YXJnZXROb2RlczogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXModHJ1ZSwgKF9kYXRhOiBhbnksIG5vZGU6IElneFRyZWVOb2RlPGFueT4pID0+IG5vZGUuZGF0YS5jb2xsYXBzaWJsZSk7XG4gICAgICogdHJlZS5jb2xsYXBzZUFsbChub2Rlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGNvbGxhcHNlQWxsKG5vZGVzPzogSWd4VHJlZU5vZGU8YW55PltdKSB7XG4gICAgICAgIG5vZGVzID0gbm9kZXMgfHwgdGhpcy5ub2Rlcy50b0FycmF5KCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZSA9PiBlLmV4cGFuZGVkID0gZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0IGFsbCBub2RlcyBpZiB0aGUgbm9kZXMgY29sbGVjdGlvbiBpcyBlbXB0eS4gT3RoZXJ3aXNlLCBkZXNlbGVjdCB0aGUgbm9kZXMgaW4gdGhlIG5vZGVzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgY29uc3QgYXJyID0gW1xuICAgICAqICAgICAgdGhpcy50cmVlLm5vZGVzLnRvQXJyYXkoKVswXSxcbiAgICAgKiAgICAgIHRoaXMudHJlZS5ub2Rlcy50b0FycmF5KClbMV1cbiAgICAgKiAgXTtcbiAgICAgKiAgdGhpcy50cmVlLmRlc2VsZWN0QWxsKGFycik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG5vZGVzOiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+W11cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RBbGwobm9kZXM/OiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+W10pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Tm9kZXNXaXRoTm9FdmVudChub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgb2YgdGhlIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIHBhc3NlZCBzZWFyY2hUZXJtLlxuICAgICAqIEFjY2VwdHMgYSBjdXN0b20gY29tcGFyZXIgZnVuY3Rpb24gZm9yIGV2YWx1YXRpbmcgdGhlIHNlYXJjaCB0ZXJtIGFnYWluc3QgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJlbWFya1xuICAgICAqIERlZmF1bHQgc2VhcmNoIGNvbXBhcmVzIHRoZSBwYXNzZWQgYHNlYXJjaFRlcm1gIGFnYWluc3QgdGhlIG5vZGUncyBgZGF0YWAgSW5wdXQuXG4gICAgICogV2hlbiB1c2luZyBgZmluZE5vZGVzYCB3L28gYSBgY29tcGFyZXJgLCBtYWtlIHN1cmUgYWxsIG5vZGVzIGhhdmUgYGRhdGFgIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWFyY2hUZXJtIFRoZSBkYXRhIG9mIHRoZSBzZWFyY2hlZCBub2RlXG4gICAgICogQHBhcmFtIGNvbXBhcmVyIEEgY3VzdG9tIGNvbXBhcmVyIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRoZSBwYXNzZWQgYHNlYXJjaFRlcm1gIGFnYWluc3QgYWxsIG5vZGVzLlxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIHNlYXJjaC4gYG51bGxgIGlmIG5vIG5vZGVzIGFyZSBmb3VuZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgIDxpZ3gtdHJlZS1ub2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZGF0YV09XCJub2RlXCI+XG4gICAgICogICAgICAgICAge3sgbm9kZS5sYWJlbCB9fVxuICAgICAqICAgICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZGF0YTogRGF0YUVudHJ5W10gPSBGRVRDSEVEX0RBVEE7XG4gICAgICogLi4uXG4gICAgICogY29uc3QgbWF0Y2hlZE5vZGVzOiBJZ3hUcmVlTm9kZTxEYXRhRW50cnk+W10gPSB0aGlzLnRyZWUuZmluZE5vZGVzPERhdGFFbnRyeT4oc2VhcmNoVGVybTogZGF0YVs1XSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2luZyBhIGN1c3RvbSBjb21wYXJlclxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZGF0YTogRGF0YUVudHJ5W10gPSBGRVRDSEVEX0RBVEE7XG4gICAgICogLi4uXG4gICAgICogY29uc3QgY29tcGFyZXI6IElneFRyZWVTZWFyY2hSZXNvbHZlciA9IChkYXRhOiBhbnksIG5vZGU6IElneFRyZWVOb2RlPERhdGFFbnRyeT4pIHtcbiAgICAgKiAgICAgIHJldHVybiBub2RlLmRhdGEuaW5kZXggJSAyID09PSAwO1xuICAgICAqIH1cbiAgICAgKiBjb25zdCBldmVuSW5kZXhOb2RlczogSWd4VHJlZU5vZGU8RGF0YUVudHJ5PltdID0gdGhpcy50cmVlLmZpbmROb2RlczxEYXRhRW50cnk+KG51bGwsIGNvbXBhcmVyKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZmluZE5vZGVzKHNlYXJjaFRlcm06IGFueSwgY29tcGFyZXI/OiBJZ3hUcmVlU2VhcmNoUmVzb2x2ZXIpOiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+W10gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY29tcGFyZUZ1bmMgPSBjb21wYXJlciB8fCB0aGlzLl9jb21wYXJlcjtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMubm9kZXMuZmlsdGVyKG5vZGUgPT4gY29tcGFyZUZ1bmMoc2VhcmNoVGVybSwgbm9kZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cz8ubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGhhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmhhbmRsZUtleWRvd24oZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZENoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlX2Rpc2FibGVkX2NhY2hlKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVOb2RlQmluZGluZ0NoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChub2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZFRvTm9kZSh0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbE5vZGVJbnRvVmlldyhub2RlPy5oZWFkZXI/Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkRlbnNpdHlDaGFuZ2VkLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE5vZGVJbnRvVmlldyh0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZT8uaGVhZGVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YlRvQ29sbGFwc2luZygpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMubm9kZXMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViVG9DaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbE5vZGVJbnRvVmlldyh0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZT8uaGVhZGVyPy5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zdWJUb0NoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJDaGlsZHJlbiQubmV4dCgpO1xuICAgICAgICB0aGlzLnVuc3ViQ2hpbGRyZW4kLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRUb05vZGUobm9kZTogSWd4VHJlZU5vZGU8YW55Pikge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGF0aC5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuICE9PSBub2RlICYmICFuLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJUb0NvbGxhcHNpbmcoKSB7XG4gICAgICAgIHRoaXMubm9kZUNvbGxhcHNpbmcucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZV92aXNpYmxlX2NhY2hlKGV2ZW50Lm5vZGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZUV4cGFuZGluZy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlX3Zpc2libGVfY2FjaGUoZXZlbnQubm9kZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3ViVG9DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnVuc3ViQ2hpbGRyZW4kLm5leHQoKTtcbiAgICAgICAgY29uc3QgdG9CZVNlbGVjdGVkID0gWy4uLnRoaXMuZm9yY2VTZWxlY3RdO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdE5vZGVzV2l0aE5vRXZlbnQodG9CZVNlbGVjdGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3QgPSBbXTtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS5leHBhbmRlZENoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLnVuc3ViQ2hpbGRyZW4kKSkuc3Vic2NyaWJlKG5vZGVTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZV92aXNpYmxlX2NhY2hlKG5vZGUsIG5vZGVTdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUuY2xvc2VBbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJDaGlsZHJlbiQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGU/LmhlYWRlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLm9wZW5BbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJDaGlsZHJlbiQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGU/LmhlYWRlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UuaW5pdF9pbnZpc2libGVfY2FjaGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbE5vZGVJbnRvVmlldyhlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRyZWVSZWN0ID0gdGhpcy5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0b3BPZmZzZXQgPSB0cmVlUmVjdC50b3AgPiBub2RlUmVjdC50b3AgPyBub2RlUmVjdC50b3AgLSB0cmVlUmVjdC50b3AgOiAwO1xuICAgICAgICBjb25zdCBib3R0b21PZmZzZXQgPSB0cmVlUmVjdC5ib3R0b20gPCBub2RlUmVjdC5ib3R0b20gPyBub2RlUmVjdC5ib3R0b20gLSB0cmVlUmVjdC5ib3R0b20gOiAwO1xuICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAhIXRvcE9mZnNldCB8fCAhIWJvdHRvbU9mZnNldDtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IG5vZGVSZWN0LnkgLSB0cmVlUmVjdC55IC0gbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wICsgYm90dG9tT2Zmc2V0ICsgdG9wT2Zmc2V0ICsgKHRvcE9mZnNldCA/IC0xIDogKzEpICogbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29tcGFyZXIgPSA8VD4oZGF0YTogVCwgbm9kZTogSWd4VHJlZU5vZGVDb21wb25lbnQ8VD4pID0+IG5vZGUuZGF0YSA9PT0gZGF0YTtcblxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBOZ01vZHVsZSBkZWZpbmluZyB0aGUgY29tcG9uZW50cyBhbmQgZGlyZWN0aXZlcyBuZWVkZWQgZm9yIGBpZ3gtdHJlZWBcbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSWd4VHJlZVNlbGVjdE1hcmtlckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4VHJlZUV4cGFuZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlLFxuICAgICAgICBJZ3hUcmVlQ29tcG9uZW50LFxuICAgICAgICBJZ3hUcmVlTm9kZUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBJZ3hJY29uTW9kdWxlLFxuICAgICAgICBJZ3hJbnB1dEdyb3VwTW9kdWxlLFxuICAgICAgICBJZ3hDaGVja2JveE1vZHVsZSxcbiAgICAgICAgSWd4UHJvZ3Jlc3NCYXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSWd4VHJlZVNlbGVjdE1hcmtlckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4VHJlZUV4cGFuZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlLFxuICAgICAgICBJZ3hUcmVlQ29tcG9uZW50LFxuICAgICAgICBJZ3hUcmVlTm9kZUNvbXBvbmVudCxcbiAgICAgICAgSWd4SWNvbk1vZHVsZSxcbiAgICAgICAgSWd4SW5wdXRHcm91cE1vZHVsZSxcbiAgICAgICAgSWd4Q2hlY2tib3hNb2R1bGUsXG4gICAgICAgIElneEV4cGFuc2lvblBhbmVsTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlTW9kdWxlIHtcbn1cbiIsIjxkaXYgY2xhc3M9XCJpZ3gtdHJlZV9fcm9vdFwiIHJvbGU9XCJ0cmVlXCIgKGtleWRvd24pPVwiaGFuZGxlS2V5ZG93bigkZXZlbnQpXCI+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXRyZWUtbm9kZVwiPjwvbmctY29udGVudD5cbjwvZGl2PlxuIl19