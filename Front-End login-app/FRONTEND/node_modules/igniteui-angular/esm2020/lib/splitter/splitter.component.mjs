import { DOCUMENT } from '@angular/common';
import { Component, ContentChildren, EventEmitter, HostBinding, HostListener, Inject, Input, Output } from '@angular/core';
import { DragDirection } from '../directives/drag-drop/drag-drop.directive';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../directives/drag-drop/drag-drop.directive";
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
        * @hidden
        * @internal
        */
        this.cssClass = 'igx-splitter';
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        this.resetPaneSizes();
        this.panes?.notifyOnChanges();
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.initPanes();
        this.panes.changes.subscribe(() => {
            this.initPanes();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method inits panes with properties.
     */
    initPanes() {
        this.panes.forEach(pane => {
            pane.owner = this;
            if (this.type === SplitterType.Horizontal) {
                pane.minWidth = pane.minSize ?? '0';
                pane.maxWidth = pane.maxSize ?? '100%';
            }
            else {
                pane.minHeight = pane.minSize ?? '0';
                pane.maxHeight = pane.maxSize ?? '100%';
            }
        });
        this.assignFlexOrder();
        if (this.panes.filter(x => x.collapsed).length > 0) {
            // if any panes are collapsed, reset sizes.
            this.resetPaneSizes();
        }
    }
    /**
     * @hidden @internal
     * This method reset pane sizes.
     */
    resetPaneSizes() {
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => {
                x.size = 'auto';
                x.minWidth = '0';
                x.maxWidth = '100%';
                x.minHeight = '0';
                x.maxHeight = '100%';
            });
        }
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
}
IgxSplitterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSplitterComponent, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
IgxSplitterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxSplitterComponent, selector: "igx-splitter", inputs: { type: "type" }, outputs: { resizeStart: "resizeStart", resizing: "resizing", resizeEnd: "resizeEnd" }, host: { properties: { "class.igx-splitter": "this.cssClass", "style.overflow": "this.overflow", "style.display": "this.display", "attr.aria-orientation": "this.orientation", "style.flex-direction": "this.direction" } }, queries: [{ propertyName: "panes", predicate: IgxSplitterPaneComponent, read: IgxSplitterPaneComponent }], ngImport: i0, template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i0.forwardRef(function () { return i1.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i0.forwardRef(function () { return i1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i0.forwardRef(function () { return IgxSplitBarComponent; }), selector: "igx-splitter-bar", inputs: ["type", "order", "pane", "siblings"], outputs: ["moveStart", "moving", "movingEnd"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSplitterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter', template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }]; }, propDecorators: { panes: [{
                type: ContentChildren,
                args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], resizeStart: [{
                type: Output
            }], resizing: [{
                type: Output
            }], resizeEnd: [{
                type: Output
            }], type: [{
                type: Input
            }], direction: [{
                type: HostBinding,
                args: ['style.flex-direction']
            }] } });
export const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
export class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
        this.movingEnd = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    onDragEnd(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.movingEnd.emit(delta);
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
}
IgxSplitBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSplitBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IgxSplitBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxSplitBarComponent, selector: "igx-splitter-bar", inputs: { type: "type", order: "order", pane: "pane", siblings: "siblings" }, outputs: { moveStart: "moveStart", moving: "moving", movingEnd: "movingEnd" }, host: { listeners: { "keydown": "keyEvent($event)" }, properties: { "class.igx-splitter-bar-host": "this.cssClass", "style.order": "this.order", "attr.tabindex": "this.tabindex", "attr.aria-orientation": "this.orientation" } }, ngImport: i0, template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.IgxDragDirective, selector: "[igxDrag]", inputs: ["igxDrag", "dragTolerance", "dragDirection", "dragChannel", "ghost", "ghostClass", "ghostTemplate", "ghostHost", "scrollContainer", "ghostOffsetX", "ghostOffsetY"], outputs: ["dragStart", "dragMove", "dragEnd", "dragClick", "ghostCreate", "ghostDestroy", "transitioned"], exportAs: ["drag"] }, { kind: "directive", type: i2.IgxDragIgnoreDirective, selector: "[igxDragIgnore]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSplitBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter-bar', template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n" }]
        }], propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter-bar-host']
            }], type: [{
                type: Input
            }], order: [{
                type: HostBinding,
                args: ['style.order']
            }, {
                type: Input
            }], tabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], pane: [{
                type: Input
            }], siblings: [{
                type: Input
            }], moveStart: [{
                type: Output
            }], moving: [{
                type: Output
            }], movingEnd: [{
                type: Output
            }], keyEvent: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci1iYXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBb0IsU0FBUyxFQUFFLGVBQWUsRUFBYyxZQUFZLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNwSyxPQUFPLEVBQUUsYUFBYSxFQUEyQyxNQUFNLDZDQUE2QyxDQUFDO0FBQ3JILE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDOzs7O0FBRW5GOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksWUFHWDtBQUhELFdBQVksWUFBWTtJQUNwQiwyREFBVSxDQUFBO0lBQ1YsdURBQVEsQ0FBQTtBQUNaLENBQUMsRUFIVyxZQUFZLEtBQVosWUFBWSxRQUd2QjtBQU9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJHO0FBS0gsTUFBTSxPQUFPLG9CQUFvQjtJQTRHN0IsWUFBcUMsUUFBUSxFQUFVLFVBQXNCO1FBQXhDLGFBQVEsR0FBUixRQUFRLENBQUE7UUFBVSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBaEc3RTs7O1VBR0U7UUFFSyxhQUFRLEdBQUcsY0FBYyxDQUFDO1FBRWpDOzs7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QVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxJQUFJLE1BQU0sQ0FBQztRQUNYLElBQUksSUFBSSxFQUFFO1lBQ04sb0ZBQW9GO1lBQ3BGLE1BQU0sR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztTQUM5RDthQUFNO1lBQ0gsb0ZBQW9GO1lBQ3BGLE1BQU0sR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztTQUM5RDtRQUNELE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNwQixDQUFDOztpSEF4T1Esb0JBQW9CO3FHQUFwQixvQkFBb0IseWJFOVZqQyxrbkJBY0E7MkZGZ1ZhLG9CQUFvQjtrQkFKaEMsU0FBUzsrQkFDSSxrQkFBa0I7OEJBUXJCLFFBQVE7c0JBRGQsV0FBVzt1QkFBQyw2QkFBNkI7Z0JBT25DLElBQUk7c0JBRFYsS0FBSztnQkFRQyxLQUFLO3NCQUZYLFdBQVc7dUJBQUMsYUFBYTs7c0JBQ3pCLEtBQUs7Z0JBUUssUUFBUTtzQkFEbEIsV0FBVzt1QkFBQyxlQUFlO2dCQVVqQixXQUFXO3NCQURyQixXQUFXO3VCQUFDLHVCQUF1QjtnQkFzQjdCLElBQUk7c0JBRFYsS0FBSztnQkFPQyxRQUFRO3NCQURkLEtBQUs7Z0JBT0MsU0FBUztzQkFEZixNQUFNO2dCQU9BLE1BQU07c0JBRFosTUFBTTtnQkFJQSxTQUFTO3NCQURmLE1BQU07Z0JBbUJBLFFBQVE7c0JBRGQsWUFBWTt1QkFBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJhZ0RpcmVjdGlvbiwgSURyYWdNb3ZlRXZlbnRBcmdzLCBJRHJhZ1N0YXJ0RXZlbnRBcmdzIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9kcmFnLWRyb3AvZHJhZy1kcm9wLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSBmcm9tICcuL3NwbGl0dGVyLXBhbmUvc3BsaXR0ZXItcGFuZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIHRoYXQgZGVmaW5lcyB0aGUgYFNwbGl0dGVyQ29tcG9uZW50YCBwYW5lcyBvcmllbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gU3BsaXR0ZXJUeXBlIHtcbiAgICBIb3Jpem9udGFsLFxuICAgIFZlcnRpY2FsXG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3Mge1xuICAgIHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcbiAgICBzaWJsaW5nOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBmcmFtZXdvcmsgZm9yIGEgc2ltcGxlIGxheW91dCwgc3BsaXR0aW5nIHRoZSB2aWV3IGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gKiBpbnRvIG11bHRpcGxlIHNtYWxsZXIgcmVzaXphYmxlIGFuZCBjb2xsYXBzaWJsZSBhcmVhcy5cbiAqXG4gKiBAaWd4TW9kdWxlIElneFNwbGl0dGVyTW9kdWxlXG4gKlxuICogQGlneFBhcmVudCBMYXlvdXRzXG4gKlxuICogQGlneFRoZW1lIGlneC1zcGxpdHRlci10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBzcGxpdHRlciBwYW5lcyBsYXlvdXRcbiAqXG4gKiBAaWd4R3JvdXAgcHJlc2VudGF0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc3BsaXR0ZXI+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogIDxpZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgLi4uXG4gKiAgPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAqIDwvaWd4LXNwbGl0dGVyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXNwbGl0dGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneFNwbGl0dGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBzcGxpdHRlciBwYW5lcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBhbmVzID0gdGhpcy5zcGxpdHRlci5wYW5lcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCwgeyByZWFkOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSlcbiAgICBwdWJsaWMgcGFuZXMhOiBRdWVyeUxpc3Q8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zcGxpdHRlcicpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1zcGxpdHRlcic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBzcGxpdHRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm92ZXJmbG93JylcbiAgICBwdWJsaWMgb3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0cy9HZXRzIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vcmllbnRhdGlvbicpXG4gICAgcHVibGljIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgc3RhcnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXplU3RhcnQpPSdyZXNpemVTdGFydCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIGlzIGluIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXppbmcpPSdyZXNpemluZygkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6aW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgZW5kcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6ZUVuZCk9J3Jlc2l6ZUVuZCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG4gICAgcHJpdmF0ZSBfdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBtYWluIGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFBhbmVTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKiBAbWVtYmVyb2YgU3BsaXR0ZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxTaWJsaW5nU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhlIG1haW4gcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYW5lITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNpYmxpbmchOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzcGxpdHRlciBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgW3R5cGVdPVwidHlwZVwiPi4uLjwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgcHVibGljIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZXNldFBhbmVTaXplcygpO1xuICAgICAgICB0aGlzLnBhbmVzPy5ub3RpZnlPbkNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIGBmbGV4LWRpcmVjdGlvbmAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYFNwbGl0dGVyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgtZGlyZWN0aW9uJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdyb3cnIDogJ2NvbHVtbic7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbml0UGFuZXMoKTtcbiAgICAgICAgdGhpcy5wYW5lcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRQYW5lcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zICBpbml0aWFsaXphdGlvbiBsb2dpYyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgc3BsaXR0ZXIgYmFyIGJldHdlZW4gZWFjaCBwYWlyIG9mIHBhbmVzLlxuICAgICAqIEBwYXJhbSBwYW5lIC0gdGhlIG1haW4gcGFuZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZlU3RhcnQocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIHRoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuc2libGluZyA9IHBhbmVzW3BhbmVzLmluZGV4T2YodGhpcy5wYW5lKSArIDFdO1xuXG4gICAgICAgIGNvbnN0IHBhbmVSZWN0ID0gdGhpcy5wYW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBhbmVTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHBhbmVSZWN0LndpZHRoIDogcGFuZVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHNpYmxpbmdSZWN0ID0gdGhpcy5zaWJsaW5nLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHNpYmxpbmdSZWN0LndpZHRoIDogc2libGluZ1JlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBhcmdzOiBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3MgPSB7IHBhbmU6IHRoaXMucGFuZSwgc2libGluZzogdGhpcy5zaWJsaW5nIH07XG4gICAgICAgIHRoaXMucmVzaXplU3RhcnQuZW1pdChhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGNhbGN1bGF0aW9ucyBjb25jZXJuaW5nIHRoZSBzaXplcyBvZiBlYWNoIHBhaXIgb2YgcGFuZXMgd2hlbiB0aGUgYmFyIGJldHdlZW4gdGhlbSBpcyBkcmFnZ2VkLlxuICAgICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkaWZmZXJlbmNlIGFsb25nIHRoZSBYIChvciBZKSBheGlzIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIHRoZSBjdXJyZW50IHBvaW50IHdoZW4gZHJhZ2dpbmcgdGhlIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZpbmcoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtaW4gPSBwYXJzZUludCh0aGlzLnBhbmUubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcnNlSW50KHRoaXMucGFuZS5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcbiAgICAgICAgY29uc3QgbWluU2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4U2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZTtcblxuICAgICAgICBjb25zdCBwYW5lU2l6ZSA9IHRoaXMuaW5pdGlhbFBhbmVTaXplIC0gZGVsdGE7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdTaXplID0gdGhpcy5pbml0aWFsU2libGluZ1NpemUgKyBkZWx0YTtcbiAgICAgICAgaWYgKHBhbmVTaXplIDwgbWluIHx8IHBhbmVTaXplID4gbWF4IHx8IHNpYmxpbmdTaXplIDwgbWluU2libGluZyB8fCBzaWJsaW5nU2l6ZSA+IG1heFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmUuZHJhZ1NpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIHRoaXMuc2libGluZy5kcmFnU2l6ZSA9IHNpYmxpbmdTaXplICsgJ3B4JztcblxuICAgICAgICBjb25zdCBhcmdzOiBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3MgPSB7IHBhbmU6IHRoaXMucGFuZSwgc2libGluZzogdGhpcy5zaWJsaW5nIH07XG4gICAgICAgIHRoaXMucmVzaXppbmcuZW1pdChhcmdzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25Nb3ZlRW5kKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWluID0gcGFyc2VJbnQodGhpcy5wYW5lLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXggPSBwYXJzZUludCh0aGlzLnBhbmUubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG4gICAgICAgIGNvbnN0IG1pblNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heFNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG5cbiAgICAgICAgY29uc3QgcGFuZVNpemUgPSB0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBzaWJsaW5nU2l6ZSA9IHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplICsgZGVsdGE7XG5cbiAgICAgICAgaWYgKHBhbmVTaXplIDwgbWluIHx8IHBhbmVTaXplID4gbWF4IHx8IHNpYmxpbmdTaXplIDwgbWluU2libGluZyB8fCBzaWJsaW5nU2l6ZSA+IG1heFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYW5lLmlzUGVyY2VudGFnZVNpemUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSAlIHJlc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50UGFuZVNpemUgPSAocGFuZVNpemUgLyB0b3RhbFNpemUpICogMTAwO1xuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwZXJjZW50UGFuZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBweCByZXNpemVcbiAgICAgICAgICAgIHRoaXMucGFuZS5zaXplID0gcGFuZVNpemUgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2libGluZy5pc1BlcmNlbnRhZ2VTaXplKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgJSByZXNpemVzXG4gICAgICAgICAgICBjb25zdCB0b3RhbFNpemUgPSB0aGlzLmdldFRvdGFsU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudFNpYmxpbmdQYW5lU2l6ZSA9IChzaWJsaW5nU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHBlcmNlbnRTaWJsaW5nUGFuZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBweCByZXNpemVcbiAgICAgICAgICAgIHRoaXMuc2libGluZy5zaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFuZS5kcmFnU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2libGluZy5kcmFnU2l6ZSA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0geyBwYW5lOiB0aGlzLnBhbmUsIHNpYmxpbmc6IHRoaXMuc2libGluZyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZUVuZC5lbWl0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXRQYW5lU2libGluZ3NCeU9yZGVyKG9yZGVyOiBudW1iZXIsIGJhckluZGV4OiBudW1iZXIpOiBBcnJheTxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+IHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLnBhbmVzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgcHJldlBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IG5leHRQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleF07XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW3ByZXZQYW5lLCBuZXh0UGFuZV07XG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRvdGFsU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSA6IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3RhbFNpemUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBpbml0cyBwYW5lcyB3aXRoIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0UGFuZXMoKSB7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaChwYW5lID0+IHtcbiAgICAgICAgICAgIHBhbmUub3duZXIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBwYW5lLm1pbldpZHRoID0gcGFuZS5taW5TaXplID8/ICcwJztcbiAgICAgICAgICAgICAgICBwYW5lLm1heFdpZHRoID0gcGFuZS5tYXhTaXplID8/ICcxMDAlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZS5taW5IZWlnaHQgPSBwYW5lLm1pblNpemUgPz8gJzAnO1xuICAgICAgICAgICAgICAgIHBhbmUubWF4SGVpZ2h0ID0gcGFuZS5tYXhTaXplID8/ICcxMDAlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXNzaWduRmxleE9yZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLnBhbmVzLmZpbHRlcih4ID0+IHguY29sbGFwc2VkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBpZiBhbnkgcGFuZXMgYXJlIGNvbGxhcHNlZCwgcmVzZXQgc2l6ZXMuXG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuZVNpemVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0IHBhbmUgc2l6ZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXNldFBhbmVTaXplcygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHR5cGUgaXMgY2hhbmdlZCBydW50aW1lLCBzaG91bGQgcmVzZXQgc2l6ZXMuXG4gICAgICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goeCA9PiB7XG4gICAgICAgICAgICAgICAgeC5zaXplID0gJ2F1dG8nXG4gICAgICAgICAgICAgICAgeC5taW5XaWR0aCA9ICcwJztcbiAgICAgICAgICAgICAgICB4Lm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIHgubWluSGVpZ2h0ID0gJzAnO1xuICAgICAgICAgICAgICAgIHgubWF4SGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIGFzc2lnbnMgdGhlIG9yZGVyIG9mIGVhY2ggcGFuZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzc2lnbkZsZXhPcmRlcigpIHtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2goKHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcGFuZS5vcmRlciA9IGs7XG4gICAgICAgICAgICBrICs9IDI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNQTElUVEVSX0lOVEVSQUNUSU9OX0tFWVMgPSBuZXcgU2V0KCdyaWdodCBkb3duIGxlZnQgdXAgYXJyb3dyaWdodCBhcnJvd2Rvd24gYXJyb3dsZWZ0IGFycm93dXAnLnNwbGl0KCcgJykpO1xuXG4vKipcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKiBSZXByZXNlbnRzIHRoZSBkcmFnZ2FibGUgYmFyIHRoYXQgdmlzdWFsbHkgc2VwYXJhdGVzIHBhbmVzIGFuZCBhbGxvd3MgZm9yIGNoYW5naW5nIHRoZWlyIHNpemVzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci1iYXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneFNwbGl0QmFyQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBTZXQgY3NzIGNsYXNzIHRvIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc3BsaXR0ZXItYmFyLWhvc3QnKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtc3BsaXR0ZXItYmFyLWhvc3QnO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBvcmllbnRhdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBTcGxpdHRlclR5cGUgPSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbDtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgZWxlbWVudCBvcmRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm9yZGVyJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvcmRlciE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyBnZXQgdGFiaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZURpc2FsbG93ZWQgPyBudWxsIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtb3JpZW50YXRpb24nKVxuICAgIHB1YmxpYyBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBjdXJzb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZURpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdjb2wtcmVzaXplJyA6ICdyb3ctcmVzaXplJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBTcGxpdFBhbmVDb21wb25lbnRgIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBgU3BsaXRCYXJDb21wb25lbnRgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFNwbGl0QmFyQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcGFuZSE6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFNldHMvR2V0cyB0aGUgYFNwbGl0UGFuZUNvbXBvbmVudGAgc2libGluZyBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBgU3BsaXRCYXJDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNpYmxpbmdzITogQXJyYXk8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuZXZlciB3ZSBzdGFydCBkcmFnZ2luZyB0aGUgY3VycmVudCBgU3BsaXRCYXJDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBtb3ZlU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbW92aW5nID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbW92aW5nRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSBob2xkZXIgZm9yIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhcnRQb2ludCE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBwcmV2QnV0dG9uSGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWJsaW5nc1swXS5jb2xsYXBzZWQgJiYgIXRoaXMuc2libGluZ3NbMV0uY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIGtleUV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBjdHJsID0gZXZlbnQuY3RybEtleTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChTUExJVFRFUl9JTlRFUkFDVElPTl9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhcnJvd3VwJzpcbiAgICAgICAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Db2xsYXBzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnQuZW1pdCh0aGlzLnBhbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdCgxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhcnJvd2Rvd24nOlxuICAgICAgICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnQuZW1pdCh0aGlzLnBhbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdCgtMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJyb3dsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92aW5nLmVtaXQoMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJyb3dyaWdodCc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Db2xsYXBzaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZURpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTdGFydC5lbWl0KHRoaXMucGFuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmluZy5lbWl0KC0xMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRyYWdEaXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gRHJhZ0RpcmVjdGlvbi5WRVJUSUNBTCA6IERyYWdEaXJlY3Rpb24uSE9SSVpPTlRBTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbmV4dEJ1dHRvbkhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3NbMV0uY29sbGFwc2VkICYmICF0aGlzLnNpYmxpbmdzWzBdLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdTdGFydChldmVudDogSURyYWdTdGFydEV2ZW50QXJncykge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBldmVudC5zdGFydFggOiBldmVudC5zdGFydFk7XG4gICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdNb3ZlKGV2ZW50OiBJRHJhZ01vdmVFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbDtcbiAgICAgICAgY29uc3QgY3VyciA9IGlzSG9yaXpvbnRhbCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5zdGFydFBvaW50IC0gY3VycjtcbiAgICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZy5lbWl0KGRlbHRhKTtcbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5vd25lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb25EcmFnRW5kKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbDtcbiAgICAgICAgY29uc3QgY3VyciA9IGlzSG9yaXpvbnRhbCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQucGFnZVk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5zdGFydFBvaW50IC0gY3VycjtcbiAgICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0VuZC5lbWl0KGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgcmVzaXplRGlzYWxsb3dlZCgpIHtcbiAgICAgICAgY29uc3QgcmVsYXRlZFRhYnMgPSB0aGlzLnNpYmxpbmdzO1xuICAgICAgICByZXR1cm4gISFyZWxhdGVkVGFicy5maW5kKHggPT4geC5yZXNpemFibGUgPT09IGZhbHNlIHx8IHguY29sbGFwc2VkID09PSB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNvbGxhcHNpbmcobmV4dDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuc2libGluZ3NbMF07XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5zaWJsaW5nc1sxXTtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIC8vIGlmIG5leHQgaXMgY2xpY2tlZCB3aGVuIHByZXYgcGFuZSBpcyBoaWRkZW4sIHNob3cgcHJldiBwYW5lLCBlbHNlIGhpZGUgbmV4dCBwYW5lLlxuICAgICAgICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmcuY29sbGFwc2VkID8gcHJldlNpYmxpbmcgOiBuZXh0U2libGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHByZXYgaXMgY2xpY2tlZCB3aGVuIG5leHQgcGFuZSBpcyBoaWRkZW4sIHNob3cgbmV4dCBwYW5lLCBlbHNlIGhpZGUgcHJldiBwYW5lLlxuICAgICAgICAgICAgdGFyZ2V0ID0gbmV4dFNpYmxpbmcuY29sbGFwc2VkID8gbmV4dFNpYmxpbmcgOiBwcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudG9nZ2xlKCk7XG4gICAgfVxufVxuIiwiPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXNwbGl0dGVyLXBhbmVcIj48L25nLWNvbnRlbnQ+XG48bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBwYW5lIG9mIHBhbmVzOyBsZXQgbGFzdCA9IGxhc3Q7IGxldCBpbmRleD0gaW5kZXg7XCI+XG4gICAgPGlneC1zcGxpdHRlci1iYXIgKm5nSWY9XCIhbGFzdFwiIFtvcmRlcl09J3BhbmUub3JkZXIgKyAxJyByb2xlPSdzZXBhcmF0b3InXG4gICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cInR5cGVcIlxuICAgICAgICAgICAgICAgICAgICBbcGFuZV09XCJwYW5lXCJcbiAgICAgICAgICAgICAgICAgICAgW3NpYmxpbmdzXT0nZ2V0UGFuZVNpYmxpbmdzQnlPcmRlcihwYW5lLm9yZGVyICsgMSwgaW5kZXgpJ1xuICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT1cIm9uTW92ZVN0YXJ0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAobW92aW5nKT1cIm9uTW92aW5nKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAobW92aW5nRW5kKT0nb25Nb3ZlRW5kKCRldmVudCknPlxuICAgIDwvaWd4LXNwbGl0dGVyLWJhcj5cbjwvbmctY29udGFpbmVyPlxuIiwiPGRpdiBjbGFzcz1cImlneC1zcGxpdHRlci1iYXJcIlxuICAgIFtjbGFzcy5pZ3gtc3BsaXR0ZXItYmFyLS12ZXJ0aWNhbF09J3R5cGUgPT09IDAnXG4gICAgW3N0eWxlLmN1cnNvcl09J2N1cnNvcidcbiAgICBpZ3hEcmFnXG4gICAgW2dob3N0XT1cImZhbHNlXCJcbiAgICBbZHJhZ0RpcmVjdGlvbl09J2RyYWdEaXInXG4gICAgKGRyYWdTdGFydCk9J29uRHJhZ1N0YXJ0KCRldmVudCknXG4gICAgKGRyYWdNb3ZlKT1cIm9uRHJhZ01vdmUoJGV2ZW50KVwiXG4gICAgKGRyYWdFbmQpPVwib25EcmFnRW5kKCRldmVudClcIlxuPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtc3BsaXR0ZXItYmFyX19leHBhbmRlci0tc3RhcnRcIiBpZ3hEcmFnSWdub3JlIChjbGljayk9J29uQ29sbGFwc2luZyhmYWxzZSknIFtoaWRkZW5dPSdwcmV2QnV0dG9uSGlkZGVuJz48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhcl9faGFuZGxlXCIgPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtc3BsaXR0ZXItYmFyX19leHBhbmRlci0tZW5kXCIgaWd4RHJhZ0lnbm9yZSAoY2xpY2spPSdvbkNvbGxhcHNpbmcodHJ1ZSknIFtoaWRkZW5dPSduZXh0QnV0dG9uSGlkZGVuJz48L2Rpdj5cbjwvZGl2PlxuIl19