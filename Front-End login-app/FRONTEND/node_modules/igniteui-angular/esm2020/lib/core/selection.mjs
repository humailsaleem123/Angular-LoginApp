import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/** @hidden */
export class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     *
     * @param componentID ID of the component.
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     *
     * @param componentID ID of the component.
     * @param newSelection The new component selection to be set.
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     *
     * @param componentID ID of the component.
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     *
     * @param componentID ID of the component.
     */
    size(componentID) {
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     *
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @returns Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     *
     * @returns Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     *
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     *
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @returns Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     *
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the items to remove from component selection.
     *
     * @returns Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     *
     * @param componentID ID of the component, which we remove item from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     *
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     *
     * @param componentID ID of the component.
     * @param itemID ID of the item to search.
     *
     * @returns If item is selected.
     */
    is_item_selected(componentID, itemID) {
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     *
     * @param componentID ID of the component.
     *
     * @returns First element in the set.
     */
    first_item(componentID) {
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     *
     * @param componentID ID of the component.
     * @param dataCount: number Number of items in the data.
     *
     * @returns If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     *
     * @param componentID ID of the component.
     * @param data Entire data array.
     *
     * @returns If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     *
     * @param data Entire data array.
     * @param primaryKey Data primary key.
     *
     * @returns Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     *
     * @returns empty set.
     */
    get_empty() {
        return new Set();
    }
}
IgxSelectionAPIService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSelectionAPIService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
IgxSelectionAPIService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSelectionAPIService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxSelectionAPIService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2NvcmUvc2VsZWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRTNDLGNBQWM7QUFJZCxNQUFNLE9BQU8sc0JBQXNCO0lBSG5DO1FBSUk7OztXQUdHO1FBQ08sY0FBUyxHQUEyQixJQUFJLEdBQUcsRUFBb0IsQ0FBQztLQXlQN0U7SUF2UEc7Ozs7T0FJRztJQUNJLEdBQUcsQ0FBQyxXQUFtQjtRQUMxQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEdBQUcsQ0FBQyxXQUFtQixFQUFFLFlBQXNCO1FBQ2xELElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDZCxNQUFNLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLFdBQW1CO1FBQzVCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLElBQUksQ0FBQyxXQUFtQjtRQUMzQixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0ksUUFB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Q0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ25HLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksU0FBUztRQUNaLE9BQU8sSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDOzttSEE3UFEsc0JBQXNCO3VIQUF0QixzQkFBc0IsY0FGbkIsTUFBTTsyRkFFVCxzQkFBc0I7a0JBSGxDLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKiogQGhpZGRlbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgSWd4U2VsZWN0aW9uQVBJU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogSWYgcHJpbWFyeUtleSBpcyBkZWZpbmVkLCB0aGVuIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBiYXNlZCBvbiB0aGUgcHJpbWFyeUtleSwgYW5kIGl0IGlzIGFycmF5IG9mIG51bWJlcnMsIHN0cmluZ3MsIGV0Yy5cbiAgICAgKiBJZiB0aGUgcHJpbWFyeUtleSBpcyBvbWl0dGVkLCB0aGVuIHNlbGVjdGlvbiBpcyBiYXNlZCBvbiB0aGUgaXRlbSBkYXRhXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNlbGVjdGlvbjogTWFwPHN0cmluZywgIFNldDxhbnk+PiA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KGNvbXBvbmVudElEOiBzdHJpbmcpOiBTZXQ8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXQoY29tcG9uZW50SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBuZXcgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBuZXdTZWxlY3Rpb24gVGhlIG5ldyBjb21wb25lbnQgc2VsZWN0aW9uIHRvIGJlIHNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0KGNvbXBvbmVudElEOiBzdHJpbmcsIG5ld1NlbGVjdGlvbjogU2V0PGFueT4pIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnRJRCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGNvbXBvbmVudCBpZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXQoY29tcG9uZW50SUQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHNlbGVjdGlvbiBmb3IgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKGNvbXBvbmVudElEOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0KGNvbXBvbmVudElELCB0aGlzLmdldF9lbXB0eSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBzaXplKGNvbXBvbmVudElEOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIHJldHVybiBzZWwgPyBzZWwuc2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgc2VsZWN0aW9uIHRoYXQgY29uc2lzdCBvZiB0aGUgbmV3IGl0ZW0gYWRkZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBUaGUgcmV0dXJuZWQgY29sbGVjdGlvbiBpcyBuZXcgU2V0LFxuICAgICAqIHRoZXJlZm9yZSBpZiB5b3Ugd2FudCB0byB1cGRhdGUgY29tcG9uZW50IHNlbGVjdGlvbiB5b3UgbmVlZCB0byBjYWxsIGluIGFkZGl0aW9uIHRoZSBzZXRfc2VsZWN0aW9uKCkgbWV0aG9kXG4gICAgICogb3IgaW5zdGVhZCB1c2UgdGhlIHNlbGVjdF9pdGVtKCkgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbSB0by5cbiAgICAgKiBAcGFyYW0gaXRlbUlEIElEIG9mIHRoZSBpdGVtIHRvIGFkZCB0byBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBzZWwgVXNlZCBpbnRlcm5hbGx5IG9ubHkgYnkgdGhlIHNlbGVjdGlvbiAoYWRkX2l0ZW1zIG1ldGhvZCkgdG8gYWNjdW11bGF0ZSBzZWxlY3Rpb24gZm9yIG11bHRpcGxlIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGFmdGVyIHRoZSBuZXcgaXRlbSBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkX2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pik6IFNldDxhbnk+IHtcbiAgICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgICAgIHNlbCA9IG5ldyBTZXQodGhpcy5nZXQoY29tcG9uZW50SUQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbCA9IHRoaXMuZ2V0X2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsLmFkZChpdGVtSUQpO1xuICAgICAgICByZXR1cm4gc2VsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNlbGVjdGlvbiB0aGF0IGNvbnNpc3Qgb2YgdGhlIG5ldyBpdGVtcyBhZGRlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIFRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIGlzIG5ldyBTZXQsXG4gICAgICogdGhlcmVmb3JlIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBjb21wb25lbnQgc2VsZWN0aW9uIHlvdSBuZWVkIHRvIGNhbGwgaW4gYWRkaXRpb24gdGhlIHNldF9zZWxlY3Rpb24oKSBtZXRob2RcbiAgICAgKiBvciBpbnN0ZWFkIHVzZSB0aGUgc2VsZWN0X2l0ZW1zKCkgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbXMgdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRHMgQXJyYXkgb2YgSURzIG9mIHRoZSBpdGVtcyB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xlYXJTZWxlY3Rpb24gSWYgdHJ1ZSBpdCB3aWxsIGNsZWFyIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNlbGVjdGlvbiBhZnRlciB0aGUgbmV3IGl0ZW1zIGFyZSBhZGRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkX2l0ZW1zKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRHM6IGFueVtdLCBjbGVhclNlbGVjdGlvbj86IGJvb2xlYW4pOiBTZXQ8YW55PiB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNldDxhbnk+O1xuICAgICAgICBpZiAoY2xlYXJTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0X2VtcHR5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbUlEcyAmJiBpdGVtSURzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IFNldCh0aGlzLmdldChjb21wb25lbnRJRCkpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1JRHMuZm9yRWFjaCgoaXRlbSkgPT4gc2VsZWN0aW9uID0gdGhpcy5hZGRfaXRlbShjb21wb25lbnRJRCwgaXRlbSwgc2VsZWN0aW9uKSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGl0ZW0gdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSBhZGQgbmV3IGl0ZW0gdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gc2VsIFVzZWQgaW50ZXJuYWxseSBvbmx5IGJ5IHRoZSBzZWxlY3Rpb24gKHNlbGVjdF9pdGVtcyBtZXRob2QpIHRvIGFjY3VtdWxhdGUgc2VsZWN0aW9uIGZvciBtdWx0aXBsZSBpdGVtcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2VsZWN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICB0aGlzLnNldChjb21wb25lbnRJRCwgdGhpcy5hZGRfaXRlbShjb21wb25lbnRJRCwgaXRlbUlELCBzZWwpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbXMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSBhZGQgbmV3IGl0ZW1zIHRvLlxuICAgICAqIEBwYXJhbSBpdGVtSURzIEFycmF5IG9mIElEcyBvZiB0aGUgaXRlbXMgdG8gYWRkIHRvIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNsZWFyU2VsZWN0aW9uIElmIHRydWUgaXQgd2lsbCBjbGVhciBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIHNlbGVjdF9pdGVtcyhjb21wb25lbnRJRDogc3RyaW5nLCBpdGVtSUQ6IGFueVtdLCBjbGVhclNlbGVjdGlvbj86IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zZXQoY29tcG9uZW50SUQsIHRoaXMuYWRkX2l0ZW1zKGNvbXBvbmVudElELCBpdGVtSUQsIGNsZWFyU2VsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgc2VsZWN0aW9uIHRoYXQgY29uc2lzdCBvZiB0aGUgbmV3IGl0ZW1zIGV4Y2x1ZGVkIGZyb20gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBUaGUgcmV0dXJuZWQgY29sbGVjdGlvbiBpcyBuZXcgU2V0LFxuICAgICAqIHRoZXJlZm9yZSBpZiB5b3Ugd2FudCB0byB1cGRhdGUgY29tcG9uZW50IHNlbGVjdGlvbiB5b3UgbmVlZCB0byBjYWxsIGluIGFkZGl0aW9uIHRoZSBzZXRfc2VsZWN0aW9uKCkgbWV0aG9kXG4gICAgICogb3IgaW5zdGVhZCB1c2UgdGhlIGRlc2VsZWN0X2l0ZW0oKSBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2UgcmVtb3ZlIGl0ZW1zIGZyb20uXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBzZWwgVXNlZCBpbnRlcm5hbGx5IG9ubHkgYnkgdGhlIHNlbGVjdGlvbiAoZGVsZXRlX2l0ZW1zIG1ldGhvZCkgdG8gYWNjdW11bGF0ZSBkZXNlbGVjdGVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGFmdGVyIHRoZSBpdGVtIGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHVibGljIGRlbGV0ZV9pdGVtKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCwgc2VsPzogU2V0PGFueT4pIHtcbiAgICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgICAgIHNlbCA9IG5ldyBTZXQodGhpcy5nZXQoY29tcG9uZW50SUQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWwuZGVsZXRlKGl0ZW1JRCk7XG4gICAgICAgIHJldHVybiBzZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgc2VsZWN0aW9uIHRoYXQgY29uc2lzdCBvZiB0aGUgbmV3IGl0ZW1zIHJlbW92ZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBUaGUgcmV0dXJuZWQgY29sbGVjdGlvbiBpcyBuZXcgU2V0LFxuICAgICAqIHRoZXJlZm9yZSBpZiB5b3Ugd2FudCB0byB1cGRhdGUgY29tcG9uZW50IHNlbGVjdGlvbiB5b3UgbmVlZCB0byBjYWxsIGluIGFkZGl0aW9uIHRoZSBzZXRfc2VsZWN0aW9uKCkgbWV0aG9kXG4gICAgICogb3IgaW5zdGVhZCB1c2UgdGhlIGRlc2VsZWN0X2l0ZW1zKCkgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIHJlbW92ZSBpdGVtcyBmcm9tLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW1zIHRvIHJlbW92ZSBmcm9tIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEczogYW55W10pOiBTZXQ8YW55PiB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNldDxhbnk+O1xuICAgICAgICBpdGVtSURzLmZvckVhY2goKGRlc2VsZWN0ZWRJdGVtKSA9PiBzZWxlY3Rpb24gPSB0aGlzLmRlbGV0ZV9pdGVtKGNvbXBvbmVudElELCBkZXNlbGVjdGVkSXRlbSwgc2VsZWN0aW9uKSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIHJlbW92ZSBpdGVtIGZyb20uXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBzZWwgVXNlZCBpbnRlcm5hbGx5IG9ubHkgYnkgdGhlIHNlbGVjdGlvbiAoZGVzZWxlY3RfaXRlbXMgbWV0aG9kKSB0byBhY2N1bXVsYXRlIHNlbGVjdGlvbiBmb3IgbXVsdGlwbGUgaXRlbXMuXG4gICAgICovXG4gICAgcHVibGljIGRlc2VsZWN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICB0aGlzLnNldChjb21wb25lbnRJRCwgdGhpcy5kZWxldGVfaXRlbShjb21wb25lbnRJRCwgaXRlbUlELCBzZWwpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaXRlbXMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSBhZGQgbmV3IGl0ZW1zIHRvLlxuICAgICAqIEBwYXJhbSBpdGVtSURzIEFycmF5IG9mIElEcyBvZiB0aGUgaXRlbXMgdG8gYWRkIHRvIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIGRlc2VsZWN0X2l0ZW1zKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRDogYW55W10sIGNsZWFyU2VsZWN0aW9uPzogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnNldChjb21wb25lbnRJRCwgdGhpcy5kZWxldGVfaXRlbXMoY29tcG9uZW50SUQsIGl0ZW1JRCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBpdGVtIGlzIHNlbGVjdGVkIGluIHRoZSBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc19pdGVtX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIGlmICghc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbC5oYXMoaXRlbUlEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIFRoaXMgaXMgY29ycmVjdCB3aGVuIHdlIGhhdmUgb25seSBvbmUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiAoZm9yIHNpbmdsZSBzZWxlY3Rpb24gcHVycG9zZXMpXG4gICAgICogYW5kIHRoZSBtZXRob2QgcmV0dXJucyB0aGF0IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZmlyc3RfaXRlbShjb21wb25lbnRJRDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHNlbCA9IHRoaXMuZ2V0KGNvbXBvbmVudElEKTtcbiAgICAgICAgaWYgKHNlbCAmJiBzZWwuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzZWwudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYWxsIGl0ZW1zIGFyZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBkYXRhQ291bnQ6IG51bWJlciBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiBhbGwgaXRlbXMgYXJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhcmVfYWxsX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcsIGRhdGFDb3VudDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBkYXRhQ291bnQgPiAwICYmIGRhdGFDb3VudCA9PT0gdGhpcy5zaXplKGNvbXBvbmVudElEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYW55IG9mIHRoZSBpdGVtcyBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBkYXRhIEVudGlyZSBkYXRhIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgSWYgdGhlcmUgaXMgYW55IGl0ZW0gc2VsZWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGFyZV9ub25lX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZShjb21wb25lbnRJRCkgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcmltYXJ5IGtleSB2YWx1ZXMgZnJvbSBhIGRhdGEgYXJyYXkuIElmIHRoZXJlIGlzbid0IGEgcHJpbWFyeSBrZXkgZGVmaW5lZCB0aGF0IHRoZSBlbnRpcmUgZGF0YSBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgRW50aXJlIGRhdGEgYXJyYXkuXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgRGF0YSBwcmltYXJ5IGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGlkZW50aWZpZXJzLCBlaXRoZXIgcHJpbWFyeSBrZXkgdmFsdWVzIG9yIHRoZSBlbnRpcmUgZGF0YSBhcnJheS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0X2FsbF9pZHMoZGF0YSwgcHJpbWFyeUtleT8pIHtcbiAgICAgICAgLy8gSWYgcHJpbWFyeUtleSBpcyAwLCB0aGlzIHNob3VsZCBzdGlsbCBtYXAgdG8gdGhlIHByb3BlcnR5XG4gICAgICAgIHJldHVybiBwcmltYXJ5S2V5ICE9PSB1bmRlZmluZWQgJiYgcHJpbWFyeUtleSAhPT0gbnVsbCA/IGRhdGEubWFwKCh4KSA9PiB4W3ByaW1hcnlLZXldKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlbXB0eSBzZWxlY3Rpb24gY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGVtcHR5IHNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0X2VtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgIH1cbn1cbiJdfQ==