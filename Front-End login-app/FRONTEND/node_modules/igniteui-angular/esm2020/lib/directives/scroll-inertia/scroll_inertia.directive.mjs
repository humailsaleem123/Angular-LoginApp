import { Directive, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.smoothingStep = 1.5;
        this.smoothingDuration = 0.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.baseDeltaMultiplier = 1 / 120;
        this.firefoxDeltaMultiplier = 1 / 30;
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            if (!this.parentElement) {
                return;
            }
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', this.onWheel.bind(this));
            targetElem.addEventListener('touchstart', this.onTouchStart.bind(this));
            targetElem.addEventListener('touchmove', this.onTouchMove.bind(this));
            targetElem.addEventListener('touchend', this.onTouchEnd.bind(this));
        });
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            if (!targetElem) {
                return;
            }
            targetElem.removeEventListener('wheel', this.onWheel);
            targetElem.removeEventListener('touchstart', this.onTouchStart);
            targetElem.removeEventListener('touchmove', this.onTouchMove);
            targetElem.removeEventListener('touchend', this.onTouchEnd);
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // if ctrl key is pressed and the user want to zoom in/out the page
        if (evt.ctrlKey) {
            return;
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        const smoothing = this.smoothingDuration !== 0;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
        }
        if (evt.composedPath && this.didChildScroll(evt, scrollDeltaX, scrollDeltaY)) {
            return;
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            const nextLeft = this._startX + scrollDeltaX * scrollStep;
            if (!smoothing) {
                this._scrollToX(nextLeft);
            }
            else {
                this._smoothWheelScroll(scrollDeltaX);
            }
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < nextLeft && nextLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'horizontal') {
            if (!smoothing) {
                const step = this._startX + scrollDeltaY * scrollStep;
                this._scrollToX(step);
            }
            else {
                this._smoothWheelScroll(scrollDeltaY);
            }
        }
        else if (!evt.shiftKey && scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            const nextTop = this._startY + scrollDeltaY * scrollStep;
            if (!smoothing) {
                this._scrollToY(nextTop);
            }
            else {
                this._smoothWheelScroll(scrollDeltaY);
            }
            this.preventParentScroll(evt, true, nextTop);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault, nextTop = 0) {
        const curScrollTop = nextTop === 0 ? this.IgxScrollInertiaScrollContainer.scrollTop : nextTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Checks if the wheel event would have scrolled an element under the display container
     * in DOM tree so that it can correctly be ignored until that element can no longer be scrolled.
     */
    didChildScroll(evt, scrollDeltaX, scrollDeltaY) {
        const path = evt.composedPath();
        let i = 0;
        while (i < path.length && path[i].localName !== 'igx-display-container') {
            const e = path[i++];
            if (e.scrollHeight > e.clientHeight) {
                const overflowY = window.getComputedStyle(e)['overflow-y'];
                if (overflowY === 'auto' || overflowY === 'scroll') {
                    if (scrollDeltaY > 0 && e.scrollHeight - Math.abs(Math.round(e.scrollTop)) !== e.clientHeight) {
                        return true;
                    }
                    if (scrollDeltaY < 0 && e.scrollTop !== 0) {
                        return true;
                    }
                }
            }
            if (e.scrollWidth > e.clientWidth) {
                const overflowX = window.getComputedStyle(e)['overflow-x'];
                if (overflowX === 'auto' || overflowX === 'scroll') {
                    if (scrollDeltaX > 0 && e.scrollWidth - Math.abs(Math.round(e.scrollLeft)) !== e.clientWidth) {
                        return true;
                    }
                    if (scrollDeltaX < 0 && e.scrollLeft !== 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    _smoothWheelScroll(delta) {
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        let x = -1;
        let wheelInertialAnimation = null;
        const inertiaWheelStep = () => {
            if (x > 1) {
                cancelAnimationFrame(wheelInertialAnimation);
                return;
            }
            const nextScroll = ((-3 * x * x + 3) * delta * 2) * this.smoothingStep;
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this._nextY += nextScroll;
                this._scrollToY(this._nextY);
            }
            else {
                this._nextX += nextScroll;
                this._scrollToX(this._nextX);
            }
            //continue the inertia
            x += 0.08 * (1 / this.smoothingDuration);
            wheelInertialAnimation = requestAnimationFrame(inertiaWheelStep);
        };
        wheelInertialAnimation = requestAnimationFrame(inertiaWheelStep);
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep;
        const inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
}
IgxScrollInertiaDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
IgxScrollInertiaDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.0", type: IgxScrollInertiaDirective, selector: "[igxScrollInertia]", inputs: { IgxScrollInertiaDirection: "IgxScrollInertiaDirection", IgxScrollInertiaScrollContainer: "IgxScrollInertiaScrollContainer", wheelStep: "wheelStep", inertiaStep: "inertiaStep", smoothingStep: "smoothingStep", smoothingDuration: "smoothingDuration", swipeToleranceX: "swipeToleranceX", inertiaDeltaY: "inertiaDeltaY", inertiaDeltaX: "inertiaDeltaX", inertiaDuration: "inertiaDuration" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[igxScrollInertia]' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { IgxScrollInertiaDirection: [{
                type: Input
            }], IgxScrollInertiaScrollContainer: [{
                type: Input
            }], wheelStep: [{
                type: Input
            }], inertiaStep: [{
                type: Input
            }], smoothingStep: [{
                type: Input
            }], smoothingDuration: [{
                type: Input
            }], swipeToleranceX: [{
                type: Input
            }], inertiaDeltaY: [{
                type: Input
            }], inertiaDeltaX: [{
                type: Input
            }], inertiaDuration: [{
                type: Input
            }] } });
/**
 * @hidden
 */
export class IgxScrollInertiaModule {
}
IgxScrollInertiaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IgxScrollInertiaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaModule, declarations: [IgxScrollInertiaDirective], imports: [CommonModule], exports: [IgxScrollInertiaDirective] });
IgxScrollInertiaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxScrollInertiaModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [IgxScrollInertiaDirective],
                    exports: [IgxScrollInertiaDirective],
                    imports: [CommonModule]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsX2luZXJ0aWEuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2RpcmVjdGl2ZXMvc2Nyb2xsLWluZXJ0aWEvc2Nyb2xsX2luZXJ0aWEuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUE4QixRQUFRLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDOztBQUUvQzs7R0FFRztBQUVILE1BQU0sT0FBTyx5QkFBeUI7SUFxRGxDLFlBQW9CLE9BQW1CLEVBQVUsS0FBYTtRQUExQyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQTVDdkQsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUdmLGdCQUFXLEdBQUcsR0FBRyxDQUFDO1FBR2xCLGtCQUFhLEdBQUcsR0FBRyxDQUFDO1FBR3BCLHNCQUFpQixHQUFHLEdBQUcsQ0FBQztRQUd4QixvQkFBZSxHQUFHLEVBQUUsQ0FBQztRQUdyQixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUdsQixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUdsQixvQkFBZSxHQUFHLEdBQUcsQ0FBQztRQVVyQixrQkFBYSxHQUFHLEVBQUUsQ0FBQztRQVVuQix3QkFBbUIsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzlCLDJCQUFzQixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFMEIsQ0FBQztJQUU1RCxRQUFRO1FBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FB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O2dCQUlDLGlCQUFpQjtzQkFEdkIsS0FBSztnQkFJQyxlQUFlO3NCQURyQixLQUFLO2dCQUlDLGFBQWE7c0JBRG5CLEtBQUs7Z0JBSUMsYUFBYTtzQkFEbkIsS0FBSztnQkFJQyxlQUFlO3NCQURyQixLQUFLOztBQWlhVjs7R0FFRztBQU9ILE1BQU0sT0FBTyxzQkFBc0I7O21IQUF0QixzQkFBc0I7b0hBQXRCLHNCQUFzQixpQkF2Y3RCLHlCQUF5QixhQW9jeEIsWUFBWSxhQXBjYix5QkFBeUI7b0hBdWN6QixzQkFBc0IsWUFIckIsWUFBWTsyRkFHYixzQkFBc0I7a0JBTmxDLFFBQVE7bUJBQUM7b0JBQ04sWUFBWSxFQUFFLENBQUMseUJBQXlCLENBQUM7b0JBQ3pDLE9BQU8sRUFBRSxDQUFDLHlCQUF5QixDQUFDO29CQUNwQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7aUJBQzFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgRWxlbWVudFJlZiwgTmdab25lLCBPbkluaXQsIE5nTW9kdWxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbaWd4U2Nyb2xsSW5lcnRpYV0nIH0pXG5leHBvcnQgY2xhc3MgSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIElneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb246IHN0cmluZztcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIElneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXI6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHdoZWVsU3RlcCA9IDUwO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5lcnRpYVN0ZXAgPSAxLjU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzbW9vdGhpbmdTdGVwID0gMS41O1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc21vb3RoaW5nRHVyYXRpb24gPSAwLjU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2lwZVRvbGVyYW5jZVggPSAyMDtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZXJ0aWFEZWx0YVkgPSAzO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5lcnRpYURlbHRhWCA9IDI7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmVydGlhRHVyYXRpb24gPSAwLjU7XG5cbiAgICBwcml2YXRlIF90b3VjaEluZXJ0aWFBbmltSUQ7XG4gICAgcHJpdmF0ZSBfc3RhcnRYO1xuICAgIHByaXZhdGUgX3N0YXJ0WTtcbiAgICBwcml2YXRlIF90b3VjaFN0YXJ0WDtcbiAgICBwcml2YXRlIF90b3VjaFN0YXJ0WTtcbiAgICBwcml2YXRlIF9sYXN0VG91Y2hFbmQ7XG4gICAgcHJpdmF0ZSBfbGFzdFRvdWNoWDtcbiAgICBwcml2YXRlIF9sYXN0VG91Y2hZO1xuICAgIHByaXZhdGUgX3NhdmVkU3BlZWRzWCA9IFtdO1xuICAgIHByaXZhdGUgX3NhdmVkU3BlZWRzWTtcbiAgICBwcml2YXRlIF90b3RhbE1vdmVkWDtcbiAgICBwcml2YXRlIF9vZmZzZXRSZWNvcmRlZDtcbiAgICBwcml2YXRlIF9vZmZzZXREaXJlY3Rpb247XG4gICAgcHJpdmF0ZSBfbGFzdE1vdmVkWDtcbiAgICBwcml2YXRlIF9sYXN0TW92ZWRZO1xuICAgIHByaXZhdGUgX25leHRYO1xuICAgIHByaXZhdGUgX25leHRZO1xuICAgIHByaXZhdGUgcGFyZW50RWxlbWVudDtcbiAgICBwcml2YXRlIGJhc2VEZWx0YU11bHRpcGxpZXIgPSAxIC8gMTIwO1xuICAgIHByaXZhdGUgZmlyZWZveERlbHRhTXVsdGlwbGllciA9IDEgLyAzMDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW0gPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0RWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBzY3JvbGxpbmcgd2l0aCB0aGUgbW91c2Ugd2hlZWwgb3IgdXNpbmcgdG91Y2hwYWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25XaGVlbChldnQpIHtcbiAgICAgICAgLy8gaWYgbm8gc2Nyb2xsYmFyIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGN0cmwga2V5IGlzIHByZXNzZWQgYW5kIHRoZSB1c2VyIHdhbnQgdG8gem9vbSBpbi9vdXQgdGhlIHBhZ2VcbiAgICAgICAgaWYgKGV2dC5jdHJsS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbERlbHRhWDtcbiAgICAgICAgbGV0IHNjcm9sbERlbHRhWTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsU3RlcCA9IHRoaXMud2hlZWxTdGVwO1xuICAgICAgICBjb25zdCBtaW5XaGVlbFN0ZXAgPSAxIC8gdGhpcy53aGVlbFN0ZXA7XG4gICAgICAgIGNvbnN0IHNtb290aGluZyA9IHRoaXMuc21vb3RoaW5nRHVyYXRpb24gIT09IDA7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG5cbiAgICAgICAgaWYgKGV2dC53aGVlbERlbHRhWCkge1xuICAgICAgICAgICAgLyogT3B0aW9uIHN1cHBvcnRlZCBvbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEuXG4gICAgICAgICAgICAvKiAxMjAgaXMgZGVmYXVsdCBmb3IgbW91c2V3aGVlbCBvbiB0aGVzZSBicm93c2Vycy4gT3RoZXIgdmFsdWVzIGFyZSBmb3IgdHJhY2twYWRzICovXG4gICAgICAgICAgICBzY3JvbGxEZWx0YVggPSAtZXZ0LndoZWVsRGVsdGFYICogdGhpcy5iYXNlRGVsdGFNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBpZiAoLW1pbldoZWVsU3RlcCA8IHNjcm9sbERlbHRhWCAmJiBzY3JvbGxEZWx0YVggPCBtaW5XaGVlbFN0ZXApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YVggPSBNYXRoLnNpZ24oc2Nyb2xsRGVsdGFYKSAqIG1pbldoZWVsU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldnQuZGVsdGFYKSB7XG4gICAgICAgICAgICAvKiBGb3Igb3RoZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBwcm92aWRlIHdoZWVsRGVsdGEsIHVzZSB0aGUgZGVsdGFZIHRvIGRldGVybWluZSBkaXJlY3Rpb24gYW5kIHBhc3MgZGVmYXVsdCB2YWx1ZXMuICovXG4gICAgICAgICAgICBjb25zdCBkZWx0YVNjYWxlZFggPSBldnQuZGVsdGFYICogKGV2dC5kZWx0YU1vZGUgPT09IDAgPyB0aGlzLmZpcmVmb3hEZWx0YU11bHRpcGxpZXIgOiAxKTtcbiAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IHRoaXMuY2FsY0F4aXNDb29yZHMoZGVsdGFTY2FsZWRYLCAtMSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogR2V0IGRlbHRhIGZvciB0aGUgWSBheGlzICovXG4gICAgICAgIGlmIChldnQud2hlZWxEZWx0YVkpIHtcbiAgICAgICAgICAgIC8qIE9wdGlvbiBzdXBwb3J0ZWQgb24gQ2hyb21lLCBTYWZhcmksIE9wZXJhLlxuICAgICAgICAgICAgLyogMTIwIGlzIGRlZmF1bHQgZm9yIG1vdXNld2hlZWwgb24gdGhlc2UgYnJvd3NlcnMuIE90aGVyIHZhbHVlcyBhcmUgZm9yIHRyYWNrcGFkcyAqL1xuICAgICAgICAgICAgc2Nyb2xsRGVsdGFZID0gLWV2dC53aGVlbERlbHRhWSAqIHRoaXMuYmFzZURlbHRhTXVsdGlwbGllcjtcblxuICAgICAgICAgICAgaWYgKC1taW5XaGVlbFN0ZXAgPCBzY3JvbGxEZWx0YVkgJiYgc2Nyb2xsRGVsdGFZIDwgbWluV2hlZWxTdGVwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGFZID0gTWF0aC5zaWduKHNjcm9sbERlbHRhWSkgKiBtaW5XaGVlbFN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZ0LmRlbHRhWSkge1xuICAgICAgICAgICAgLyogRm9yIG90aGVyIGJyb3dzZXJzIHRoYXQgZG9uJ3QgcHJvdmlkZSB3aGVlbERlbHRhLCB1c2UgdGhlIGRlbHRhWSB0byBkZXRlcm1pbmUgZGlyZWN0aW9uIGFuZCBwYXNzIGRlZmF1bHQgdmFsdWVzLiAqL1xuICAgICAgICAgICAgY29uc3QgZGVsdGFTY2FsZWRZID0gZXZ0LmRlbHRhWSAqIChldnQuZGVsdGFNb2RlID09PSAwID8gdGhpcy5maXJlZm94RGVsdGFNdWx0aXBsaWVyIDogMSk7XG4gICAgICAgICAgICBzY3JvbGxEZWx0YVkgPSB0aGlzLmNhbGNBeGlzQ29vcmRzKGRlbHRhU2NhbGVkWSwgLTEsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2dC5jb21wb3NlZFBhdGggJiYgdGhpcy5kaWRDaGlsZFNjcm9sbChldnQsIHNjcm9sbERlbHRhWCwgc2Nyb2xsRGVsdGFZKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbERlbHRhWCAmJiB0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgbmV4dExlZnQgPSB0aGlzLl9zdGFydFggKyBzY3JvbGxEZWx0YVggKiBzY3JvbGxTdGVwO1xuICAgICAgICAgICAgaWYgKCFzbW9vdGhpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb1gobmV4dExlZnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbW9vdGhXaGVlbFNjcm9sbChzY3JvbGxEZWx0YVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4U2Nyb2xsTGVmdCA9IHBhcnNlSW50KHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApO1xuICAgICAgICAgICAgaWYgKDAgPCBuZXh0TGVmdCAmJiBuZXh0TGVmdCA8IG1heFNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5hdmlnYXRpbmcgdGhyb3VnaCBwYWdlcyB3aGVuIHNjcm9sbGluZyBvbiBNYWNcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldnQuc2hpZnRLZXkgJiYgc2Nyb2xsRGVsdGFZICYmIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBpZiAoIXNtb290aGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLl9zdGFydFggKyBzY3JvbGxEZWx0YVkgKiBzY3JvbGxTdGVwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvWChzdGVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc21vb3RoV2hlZWxTY3JvbGwoc2Nyb2xsRGVsdGFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZXZ0LnNoaWZ0S2V5ICYmIHNjcm9sbERlbHRhWSAmJiB0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUb3AgPSB0aGlzLl9zdGFydFkgKyBzY3JvbGxEZWx0YVkgKiBzY3JvbGxTdGVwO1xuICAgICAgICAgICAgaWYgKCFzbW9vdGhpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb1kobmV4dFRvcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Ntb290aFdoZWVsU2Nyb2xsKHNjcm9sbERlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZ0LCB0cnVlLCBuZXh0VG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBXaGVuIHRoZXJlIGlzIHN0aWxsIHJvb20gdG8gc2Nyb2xsIHVwL2Rvd24gcHJldmVudCB0aGUgcGFyZW50IGVsZW1lbnRzIGZyb20gc2Nyb2xsaW5nIHRvby5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcHJldmVudFBhcmVudFNjcm9sbChldnQsIHByZXZlbnREZWZhdWx0LCBuZXh0VG9wID0gMCkge1xuICAgICAgICBjb25zdCBjdXJTY3JvbGxUb3AgPSBuZXh0VG9wID09PSAwID8gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA6IG5leHRUb3A7XG4gICAgICAgIGNvbnN0IG1heFNjcm9sbFRvcCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5jaGlsZHJlblswXS5zY3JvbGxIZWlnaHQgLVxuICAgICAgICAgICAgdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKDAgPCBjdXJTY3JvbGxUb3AgJiYgY3VyU2Nyb2xsVG9wIDwgbWF4U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENoZWNrcyBpZiB0aGUgd2hlZWwgZXZlbnQgd291bGQgaGF2ZSBzY3JvbGxlZCBhbiBlbGVtZW50IHVuZGVyIHRoZSBkaXNwbGF5IGNvbnRhaW5lclxuICAgICAqIGluIERPTSB0cmVlIHNvIHRoYXQgaXQgY2FuIGNvcnJlY3RseSBiZSBpZ25vcmVkIHVudGlsIHRoYXQgZWxlbWVudCBjYW4gbm8gbG9uZ2VyIGJlIHNjcm9sbGVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaWRDaGlsZFNjcm9sbChldnQsIHNjcm9sbERlbHRhWCwgc2Nyb2xsRGVsdGFZKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBldnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCAmJiBwYXRoW2ldLmxvY2FsTmFtZSAhPT0gJ2lneC1kaXNwbGF5LWNvbnRhaW5lcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBwYXRoW2krK107XG4gICAgICAgICAgICBpZiAoZS5zY3JvbGxIZWlnaHQgPiBlLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93WSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpWydvdmVyZmxvdy15J107XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbERlbHRhWSA+IDAgJiYgZS5zY3JvbGxIZWlnaHQgLSBNYXRoLmFicyhNYXRoLnJvdW5kKGUuc2Nyb2xsVG9wKSkgIT09IGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsRGVsdGFZIDwgMCAmJiBlLnNjcm9sbFRvcCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5zY3JvbGxXaWR0aCA+IGUuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVyZmxvd1ggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKVsnb3ZlcmZsb3cteCddO1xuICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBvdmVyZmxvd1ggPT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxEZWx0YVggPiAwICYmIGUuc2Nyb2xsV2lkdGggLSBNYXRoLmFicyhNYXRoLnJvdW5kKGUuc2Nyb2xsTGVmdCkpICE9PSBlLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsRGVsdGFYIDwgMCAmJiBlLnNjcm9sbExlZnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdGhlIGZpcnN0IG1vbWVudCB3ZSBzdGFydCBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb250ZW50IG9uIGEgdG91Y2ggZGV2aWNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcHMgYW55IGN1cnJlbnQgb25nb2luZyBpbmVydGlhXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RvdWNoSW5lcnRpYUFuaW1JRCk7XG5cbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG5cbiAgICAgICAgdGhpcy5fdG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdGhpcy5fdG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgICB0aGlzLl9sYXN0VG91Y2hFbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hZID0gdG91Y2gucGFnZVk7XG4gICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWCA9IFtdO1xuICAgICAgICB0aGlzLl9zYXZlZFNwZWVkc1kgPSBbXTtcblxuICAgICAgICAvLyBWYXJzIHJlZ2FyZGluZyBzd2lwZSBvZmZzZXRcbiAgICAgICAgdGhpcy5fdG90YWxNb3ZlZFggPSAwO1xuICAgICAgICB0aGlzLl9vZmZzZXRSZWNvcmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vZmZzZXREaXJlY3Rpb24gPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFBhcmVudFNjcm9sbChldmVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gd2UgbmVlZCB0byBzY3JvbGwgdGhlIGNvbnRlbnQgYmFzZWQgb24gdG91Y2ggaW50ZXJhY3Rpb25zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIGNvbnN0IGRlc3RYID0gdGhpcy5fc3RhcnRYICsgKHRoaXMuX3RvdWNoU3RhcnRYIC0gdG91Y2gucGFnZVgpICogTWF0aC5zaWduKHRoaXMuaW5lcnRpYVN0ZXApO1xuICAgICAgICBjb25zdCBkZXN0WSA9IHRoaXMuX3N0YXJ0WSArICh0aGlzLl90b3VjaFN0YXJ0WSAtIHRvdWNoLnBhZ2VZKSAqIE1hdGguc2lnbih0aGlzLmluZXJ0aWFTdGVwKTtcblxuICAgICAgICAvKiBIYW5kbGUgY29tcGxleCB0b3VjaG1vdmVzIHdoZW4gc3dpcGUgc3RvcHMgYnV0IHRoZSB0b2NoIGRvZXNuJ3QgZW5kIGFuZCB0aGVuIGEgc3dpcGUgaXMgaW5pdGlhdGVkIGFnYWluICovXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgICAgICBjb25zdCB0aW1lRnJvbUxhc3RUb3VjaCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9sYXN0VG91Y2hFbmQ7XG4gICAgICAgIGlmICh0aW1lRnJvbUxhc3RUb3VjaCAhPT0gMCAmJiB0aW1lRnJvbUxhc3RUb3VjaCA8IDEwMCkge1xuICAgICAgICAgICAgY29uc3Qgc3BlZWRYID0gKHRoaXMuX2xhc3RUb3VjaFggLSB0b3VjaC5wYWdlWCkgLyB0aW1lRnJvbUxhc3RUb3VjaDtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkWSA9ICh0aGlzLl9sYXN0VG91Y2hZIC0gdG91Y2gucGFnZVkpIC8gdGltZUZyb21MYXN0VG91Y2g7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgNSBzcGVlZHMgYmV0d2VlbiB0d28gdG91Y2htb3ZlcyBvbiBYIGF4aXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5wdXNoKHNwZWVkWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5wdXNoKHNwZWVkWCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgNSBzcGVlZHMgYmV0d2VlbiB0d28gdG91Y2htb3ZlcyBvbiBZIGF4aXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFNwZWVkc1kubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5wdXNoKHNwZWVkWSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5wdXNoKHNwZWVkWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuX2xhc3RNb3ZlZFggPSB0aGlzLl9sYXN0VG91Y2hYIC0gdG91Y2gucGFnZVg7XG4gICAgICAgIHRoaXMuX2xhc3RNb3ZlZFkgPSB0aGlzLl9sYXN0VG91Y2hZIC0gdG91Y2gucGFnZVk7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaFggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICAgIHRoaXMuX3RvdGFsTW92ZWRYICs9IHRoaXMuX2xhc3RNb3ZlZFg7XG5cbiAgICAgICAgLypcdERvIG5vdCBzY3JvbGwgdXNpbmcgdG91Y2ggdW50aWxsIG91dCBvZiB0aGUgc3dpcGVUb2xlcmFuY2VYIGJvdW5kcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fdG90YWxNb3ZlZFgpIDwgdGhpcy5zd2lwZVRvbGVyYW5jZVggJiYgIXRoaXMuX29mZnNldFJlY29yZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zdGFydFgsIGRlc3RZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qXHRSZWNvcmQgdGhlIGRpcmVjdGlvbiB0aGUgZmlyc3QgdGltZSB3ZSBhcmUgb3V0IG9mIHRoZSBzd2lwZVRvbGVyYW5jZVggYm91bmRzLlxuICAgICAgICAgICAgKlx0VGhhdCB3YXkgd2Uga25vdyB3aGljaCBkaXJlY3Rpb24gd2UgYXBwbHkgdGhlIG9mZnNldCBzbyBpdCBkb2Vzbid0IGhpY2t1cCB3aGVuIG1vdmluZyBvdXQgb2YgdGhlIHN3aXBlVG9sZXJhbmNlWCBib3VuZHMgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5fb2Zmc2V0UmVjb3JkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXREaXJlY3Rpb24gPSBNYXRoLnNpZ24oZGVzdFggLSB0aGlzLl9zdGFydFgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldFJlY29yZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcdFNjcm9sbCB3aXRoIG9mZnNldCBhbW1vdXQgb2Ygc3dpcGVUb2xlcmFuY2VYIGluIHRoZSBkaXJlY3Rpb24gd2UgaGF2ZSBleGl0ZWQgdGhlIGJvdW5kcyBhbmRcbiAgICAgICAgICAgIGRvbid0IGNoYW5nZSBpdCBhZnRlciB0aGF0IGV2ZXIgdW50aWwgdG91Y2hlbmQgYW5kIGFnYWluIHRvdWNoc3RhcnQgKi9cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKGRlc3RYIC0gdGhpcy5fb2Zmc2V0RGlyZWN0aW9uICogdGhpcy5zd2lwZVRvbGVyYW5jZVgsIGRlc3RZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9uIFNhZmFyaSBwcmV2ZW50aW5nIHRoZSB0b3VjaG1vdmUgd291bGQgcHJldmVudCBkZWZhdWx0IHBhZ2Ugc2Nyb2xsIGJlaGF2aW91ciBldmVuIGlmIHRoZXJlIGlzIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBvdmVyZmxvd1xuICAgICAgICBpZiAodGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNwZWVkWCA9IDA7XG4gICAgICAgIGxldCBzcGVlZFkgPSAwO1xuXG4gICAgICAgIC8vIHNhdmVkU3BlZWRzWCBhbmQgc2F2ZWRTcGVlZHNZIGhhdmUgc2FtZSBsZW5ndGhcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNwZWVkWCArPSB0aGlzLl9zYXZlZFNwZWVkc1hbaV07XG4gICAgICAgICAgICBzcGVlZFkgKz0gdGhpcy5fc2F2ZWRTcGVlZHNZW2ldO1xuICAgICAgICB9XG4gICAgICAgIHNwZWVkWCA9IHRoaXMuX3NhdmVkU3BlZWRzWC5sZW5ndGggPyBzcGVlZFggLyB0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoIDogMDtcbiAgICAgICAgc3BlZWRZID0gdGhpcy5fc2F2ZWRTcGVlZHNYLmxlbmd0aCA/IHNwZWVkWSAvIHRoaXMuX3NhdmVkU3BlZWRzWS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIFVzZSB0aGUgbGFzdE1vdmVkWCBhbmQgbGFzdE1vdmVkWSB0byBkZXRlcm1pbmUgaWYgdGhlIHN3aXBlIHN0b3BzIHdpdGhvdXQgbGlmdGluZyB0aGUgZmluZ2VyIHNvIHdlIGRvbid0IHN0YXJ0IGluZXJ0aWFcbiAgICAgICAgaWYgKChNYXRoLmFicyhzcGVlZFgpID4gMC4xIHx8IE1hdGguYWJzKHNwZWVkWSkgPiAwLjEpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fbGFzdE1vdmVkWCkgPiAyIHx8IE1hdGguYWJzKHRoaXMuX2xhc3RNb3ZlZFkpID4gMikpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0aWFJbml0KHNwZWVkWCwgc3BlZWRZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfc21vb3RoV2hlZWxTY3JvbGwoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fbmV4dFkgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLl9uZXh0WCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICBsZXQgeCA9IC0xO1xuICAgICAgICBsZXQgd2hlZWxJbmVydGlhbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGluZXJ0aWFXaGVlbFN0ZXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoeCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh3aGVlbEluZXJ0aWFsQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0U2Nyb2xsID0gKCgtMyAqIHggKiB4ICsgMykgKiBkZWx0YSAqIDIpICogdGhpcy5zbW9vdGhpbmdTdGVwO1xuICAgICAgICAgICAgaWYgKHRoaXMuSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRZICs9IG5leHRTY3JvbGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9ZKHRoaXMuX25leHRZKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFggKz0gbmV4dFNjcm9sbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb1godGhpcy5fbmV4dFgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb250aW51ZSB0aGUgaW5lcnRpYVxuICAgICAgICAgICAgeCArPSAwLjA4ICogKDEgLyB0aGlzLnNtb290aGluZ0R1cmF0aW9uKTtcbiAgICAgICAgICAgIHdoZWVsSW5lcnRpYWxBbmltYXRpb24gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaW5lcnRpYVdoZWVsU3RlcCk7XG4gICAgICAgIH07XG4gICAgICAgIHdoZWVsSW5lcnRpYWxBbmltYXRpb24gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaW5lcnRpYVdoZWVsU3RlcCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9pbmVydGlhSW5pdChzcGVlZFgsIHNwZWVkWSkge1xuICAgICAgICBjb25zdCBzdGVwTW9kaWZlciA9IHRoaXMuaW5lcnRpYVN0ZXA7XG4gICAgICAgIGNvbnN0IGluZXJ0aWFEdXJhdGlvbiA9IHRoaXMuaW5lcnRpYUR1cmF0aW9uO1xuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIHRoaXMuX25leHRYID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgIHRoaXMuX25leHRZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuICAgICAgICAvLyBTZXRzIHRpbWVvdXQgdW50aWwgZXhlY3V0aW5nIG5leHQgbW92ZW1lbnQgaXRlcmF0aW9uIG9mIHRoZSBpbmVydGlhXG4gICAgICAgIGNvbnN0IGluZXJ0aWFTdGVwID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHggPiA2KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGVlZFgpID4gTWF0aC5hYnMoc3BlZWRZKSkge1xuICAgICAgICAgICAgICAgIHggKz0gMC4wNSAvICgxICogaW5lcnRpYUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCArPSAwLjA1IC8gKDEgKiBpbmVydGlhRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGNvbnN0YW50IHF1YXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBvZmZzZXQgd2l0aG91dCBzcGVlZCBmYWxsb2ZmIGJlZm9yIHggcmVhY2hlcyAxXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkWSkgPD0gTWF0aC5hYnMoc3BlZWRYKSAqIHRoaXMuaW5lcnRpYURlbHRhWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0WCArPSAxICogc3BlZWRYICogMTUgKiBzdGVwTW9kaWZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkWSkgPj0gTWF0aC5hYnMoc3BlZWRYKSAqIHRoaXMuaW5lcnRpYURlbHRhWCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0WSArPSAxICogc3BlZWRZICogMTUgKiBzdGVwTW9kaWZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgcXVhdGlvbiBcInkgPSAyIC8gKHggKyAwLjU1KSAtIDAuM1wiIHRvIGRldGVybWluZSB0aGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkWSkgPD0gTWF0aC5hYnMoc3BlZWRYKSAqIHRoaXMuaW5lcnRpYURlbHRhWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0WCArPSBNYXRoLmFicygyIC8gKHggKyAwLjU1KSAtIDAuMykgKiBzcGVlZFggKiAxNSAqIHN0ZXBNb2RpZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWRZKSA+PSBNYXRoLmFicyhzcGVlZFgpICogdGhpcy5pbmVydGlhRGVsdGFYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRZICs9IE1hdGguYWJzKDIgLyAoeCArIDAuNTUpIC0gMC4zKSAqIHNwZWVkWSAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1peGVkIGVudmlyb25tZW50IHdlIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuIGkuZS4gdG91Y2hzY3JlZW4gKyBtb3VzZVxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fbmV4dFgsIHRoaXMuX25leHRZKTtcblxuICAgICAgICAgICAgdGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGluZXJ0aWFTdGVwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdGFydCBpbmVydGlhIGFuZCBjb250aW51ZSBpdCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLl90b3VjaEluZXJ0aWFBbmltSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaW5lcnRpYVN0ZXApO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FsY0F4aXNDb29yZHModGFyZ2V0LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0IDwgbWluKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBtaW47XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID4gbWF4KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgX3Njcm9sbFRvKGRlc3RYLCBkZXN0WSkge1xuICAgICAgICAvLyBUT0RPIFRyaWdnZXIgc2Nyb2xsaW5nIGV2ZW50P1xuICAgICAgICBjb25zdCBzY3JvbGxlZFggPSB0aGlzLl9zY3JvbGxUb1goZGVzdFgpO1xuICAgICAgICBjb25zdCBzY3JvbGxlZFkgPSB0aGlzLl9zY3JvbGxUb1koZGVzdFkpO1xuXG4gICAgICAgIHJldHVybiB7IHg6IHNjcm9sbGVkWCwgeTogc2Nyb2xsZWRZIH07XG4gICAgfVxuICAgIHByaXZhdGUgX3Njcm9sbFRvWChkZXN0KSB7XG4gICAgICAgIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID0gZGVzdDtcbiAgICB9XG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9ZKGRlc3QpIHtcbiAgICAgICAgdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IGRlc3Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hTY3JvbGxJbmVydGlhRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGl2ZV0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hTY3JvbGxJbmVydGlhTW9kdWxlIHtcbn1cblxuIl19