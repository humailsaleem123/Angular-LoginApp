import { useAnimation } from '@angular/animations';
import { CommonModule } from '@angular/common';
import { Component, ContentChild, ContentChildren, EventEmitter, HostBinding, Inject, Input, NgModule, Output, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { growVerIn, growVerOut } from '../animations/grow';
import { fadeIn } from '../animations/main';
import { IgxCarouselComponentBase } from '../carousel/carousel-base';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxAngularAnimationService } from '../services/animation/angular-animation-service';
import { IgxStepComponent } from './step/step.component';
import { IgxStepperOrientation, IgxStepperTitlePosition, IgxStepType, IGX_STEPPER_COMPONENT, VerticalAnimationType } from './stepper.common';
import { IgxStepActiveIndicatorDirective, IgxStepCompletedIndicatorDirective, IgxStepContentDirective, IgxStepIndicatorDirective, IgxStepInvalidIndicatorDirective, IgxStepSubTitleDirective, IgxStepTitleDirective } from './stepper.directive';
import { IgxStepperService } from './stepper.service';
import * as i0 from "@angular/core";
import * as i1 from "./stepper.service";
import * as i2 from "@angular/common";
// TODO: common interface between IgxCarouselComponentBase and ToggleAnimationPlayer?
/**
 * IgxStepper provides a wizard-like workflow by dividing content into logical steps.
 *
 * @igxModule IgxStepperModule
 *
 * @igxKeywords stepper
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Stepper component allows the user to navigate between multiple steps.
 * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.
 * The component offers keyboard navigation and API to control the active step.
 *
 * @example
 * ```html
 * <igx-stepper>
 *  <igx-step [active]="true">
 *      <igx-icon igxStepIndicator>home</igx-icon>
 *      <p igxStepTitle>Home</p>
 *      <div igxStepContent>
 *         ...
 *      </div>
 *  </igx-step>
 *  <igx-step [optional]="true">
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 *  <igx-step>
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 * </igx-stepper>
 * ```
 */
export class IgxStepperComponent extends IgxCarouselComponentBase {
    constructor(cdr, animationService, stepperService, element) {
        super(animationService, cdr);
        this.stepperService = stepperService;
        this.element = element;
        /**
         * Get/Set the type of the steps.
         *
         * ```typescript
         * this.stepper.stepType = IgxStepType.Indicator;
         * ```
         */
        this.stepType = IgxStepType.Full;
        /**
         * Get/Set whether the content is displayed above the steps.
         *
         * @remarks
         * Default value is `false` and the content is below the steps.
         *
         * ```typescript
         * this.stepper.contentTop = true;
         * ```
         */
        this.contentTop = false;
        /**
         * Get/Set the position of the steps title.
         *
         * @remarks
         * The default value when the stepper is horizontally orientated is `bottom`.
         * In vertical layout the default title position is `end`.
         *
         * ```typescript
         * this.stepper.titlePosition = IgxStepperTitlePosition.Top;
         * ```
         */
        this.titlePosition = null;
        /** @hidden @internal **/
        this.cssClass = 'igx-stepper';
        /** @hidden @internal **/
        this.role = 'tablist';
        /**
         * Emitted when the stepper's active step is changing.
         *
         *```html
         * <igx-stepper (activeStepChanging)="handleActiveStepChanging($event)">
         * </igx-stepper>
         * ```
         *
         *```typescript
         * public handleActiveStepChanging(event: IStepChangingEventArgs) {
         *  if (event.newIndex < event.oldIndex) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.activeStepChanging = new EventEmitter();
        /**
         * Emitted when the active step is changed.
         *
         * @example
         * ```
         * <igx-stepper (activeStepChanged)="handleActiveStepChanged($event)"></igx-stepper>
         * ```
         */
        this.activeStepChanged = new EventEmitter();
        /** @hidden @internal */
        this.verticalAnimationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut,
        };
        /** @hidden @internal */
        this._defaultTitlePosition = IgxStepperTitlePosition.Bottom;
        this.destroy$ = new Subject();
        this._orientation = IgxStepperOrientation.Horizontal;
        this._verticalAnimationType = VerticalAnimationType.Grow;
        this._linear = false;
        this._defaultAnimationDuration = 350;
        this.stepperService.stepper = this;
    }
    /**
     * Get/Set the animation type of the stepper when the orientation direction is vertical.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper verticalAnimationType="none">
     * <igx-stepper>
     * ```
     */
    get verticalAnimationType() {
        return this._verticalAnimationType;
    }
    set verticalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this._verticalAnimationType = value;
        switch (value) {
            case 'grow':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(growVerIn, growVerOut);
                break;
            case 'fade':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(fadeIn, null);
                break;
            case 'none':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(null, null);
                break;
        }
    }
    /**
     * Get/Set the animation type of the stepper when the orientation direction is horizontal.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper animationType="none">
     * <igx-stepper>
     * ```
     */
    get horizontalAnimationType() {
        return this.animationType;
    }
    set horizontalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this.animationType = value;
    }
    /**
     * Get/Set the animation duration.
     * ```html
     * <igx-stepper [animationDuration]="500">
     * <igx-stepper>
     * ```
     */
    get animationDuration() {
        return this.defaultAnimationDuration;
    }
    set animationDuration(value) {
        if (value && value > 0) {
            this.defaultAnimationDuration = value;
            return;
        }
        this.defaultAnimationDuration = this._defaultAnimationDuration;
    }
    /**
     * Get/Set whether the stepper is linear.
     *
     * @remarks
     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.
     *
     * ```html
     * <igx-stepper [linear]="true"></igx-stepper>
     * ```
     */
    get linear() {
        return this._linear;
    }
    set linear(value) {
        this._linear = value;
        if (this._linear && this.steps.length > 0) {
            // when the stepper is in linear mode we should calculate which steps should be disabled
            // and which are visited i.e. their validity should be correctly displayed.
            this.stepperService.calculateVisitedSteps();
            this.stepperService.calculateLinearDisabledSteps();
        }
        else {
            this.stepperService.linearDisabledSteps.clear();
        }
    }
    /**
     * Get/Set the stepper orientation.
     *
     * ```typescript
     * this.stepper.orientation = IgxStepperOrientation.Vertical;
     * ```
     */
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        if (this._orientation === value) {
            return;
        }
        // TODO: activeChange event is not emitted for the collapsing steps
        this.stepperService.collapsingSteps.clear();
        this._orientation = value;
        this._defaultTitlePosition = this._orientation === IgxStepperOrientation.Horizontal ?
            IgxStepperTitlePosition.Bottom : IgxStepperTitlePosition.End;
    }
    /** @hidden @internal **/
    get directionClass() {
        return this.orientation === IgxStepperOrientation.Horizontal;
    }
    /**
     * Get all steps.
     *
     * ```typescript
     * const steps: IgxStepComponent[] = this.stepper.steps;
     * ```
     */
    get steps() {
        return this._steps?.toArray() || [];
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['animationDuration']) {
            this.verticalAnimationType = this._verticalAnimationType;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.enterAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.activeStepChanged.emit({ owner: this, index: this.stepperService.activeStep.index });
        });
        this.leaveAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.stepperService.collapsingSteps.size === 1) {
                this.stepperService.collapse(this.stepperService.previousActiveStep);
            }
            else {
                Array.from(this.stepperService.collapsingSteps).slice(0, this.stepperService.collapsingSteps.size - 1)
                    .forEach(step => this.stepperService.collapse(step));
            }
        });
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        let activeStep;
        this.steps.forEach((step, index) => {
            this.updateStepAria(step, index);
            if (!activeStep && step.active) {
                activeStep = step;
            }
        });
        if (!activeStep) {
            this.activateFirstStep(true);
        }
        this.handleStepChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Activates the step at a given index.
     *
     *```typescript
     * this.stepper.navigateTo(1);
     *```
     */
    navigateTo(index) {
        const step = this.steps[index];
        if (!step || this.stepperService.activeStep === step) {
            return;
        }
        this.activateStep(step);
    }
    /**
     * Activates the next enabled step.
     *
     *```typescript
     * this.stepper.next();
     *```
     */
    next() {
        this.moveToNextStep();
    }
    /**
     * Activates the previous enabled step.
     *
     *```typescript
     * this.stepper.prev();
     *```
     */
    prev() {
        this.moveToNextStep(false);
    }
    /**
     * Resets the stepper to its initial state i.e. activates the first step.
     *
     * @remarks
     * The steps' content will not be automatically reset.
     *```typescript
     * this.stepper.reset();
     *```
     */
    reset() {
        this.stepperService.visitedSteps.clear();
        const activeStep = this.steps.find(s => !s.disabled);
        if (activeStep) {
            this.activateStep(activeStep);
        }
    }
    /** @hidden @internal */
    playHorizontalAnimations() {
        this.previousItem = this.stepperService.previousActiveStep;
        this.currentItem = this.stepperService.activeStep;
        this.triggerAnimations();
    }
    getPreviousElement() {
        return this.stepperService.previousActiveStep?.contentContainer.nativeElement;
    }
    getCurrentElement() {
        return this.stepperService.activeStep.contentContainer.nativeElement;
    }
    updateVerticalAnimationSettings(openAnimation, closeAnimation) {
        const customCloseAnimation = useAnimation(closeAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        const customOpenAnimation = useAnimation(openAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        return {
            openAnimation: openAnimation ? customOpenAnimation : null,
            closeAnimation: closeAnimation ? customCloseAnimation : null
        };
    }
    updateStepAria(step, index) {
        step._index = index;
        step.renderer.setAttribute(step.nativeElement, 'aria-setsize', (this.steps.length).toString());
        step.renderer.setAttribute(step.nativeElement, 'aria-posinset', (index + 1).toString());
    }
    handleStepChanges() {
        this._steps.changes.pipe(takeUntil(this.destroy$)).subscribe(steps => {
            Promise.resolve().then(() => {
                steps.forEach((step, index) => {
                    this.updateStepAria(step, index);
                });
                // when the active step is removed
                const hasActiveStep = this.steps.find(s => s === this.stepperService.activeStep);
                if (!hasActiveStep) {
                    this.activateFirstStep();
                }
                // TO DO: mark step added before the active as visited?
                if (this.linear) {
                    this.stepperService.calculateLinearDisabledSteps();
                }
            });
        });
    }
    activateFirstStep(activateInitially = false) {
        const firstEnabledStep = this.steps.find(s => !s.disabled);
        if (firstEnabledStep) {
            firstEnabledStep.active = true;
            if (activateInitially) {
                firstEnabledStep.activeChange.emit(true);
                this.activeStepChanged.emit({ owner: this, index: firstEnabledStep.index });
            }
        }
    }
    activateStep(step) {
        if (this.orientation === IgxStepperOrientation.Horizontal) {
            step.changeHorizontalActiveStep();
        }
        else {
            this.stepperService.expand(step);
        }
    }
    moveToNextStep(next = true) {
        let steps = this.steps;
        let activeStepIndex = this.stepperService.activeStep.index;
        if (!next) {
            steps = this.steps.reverse();
            activeStepIndex = steps.findIndex(s => s === this.stepperService.activeStep);
        }
        const nextStep = steps.find((s, i) => i > activeStepIndex && s.isAccessible);
        if (nextStep) {
            this.activateStep(nextStep);
        }
    }
}
IgxStepperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i1.IgxStepperService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
IgxStepperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxStepperComponent, selector: "igx-stepper", inputs: { verticalAnimationType: "verticalAnimationType", horizontalAnimationType: "horizontalAnimationType", animationDuration: "animationDuration", linear: "linear", orientation: "orientation", stepType: "stepType", contentTop: "contentTop", titlePosition: "titlePosition" }, outputs: { activeStepChanging: "activeStepChanging", activeStepChanged: "activeStepChanged" }, host: { properties: { "attr.aria-orientation": "this.orientation", "class.igx-stepper": "this.cssClass", "attr.role": "this.role", "class.igx-stepper--horizontal": "this.directionClass" } }, providers: [
        IgxStepperService,
        { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
    ], queries: [{ propertyName: "invalidIndicatorTemplate", first: true, predicate: IgxStepInvalidIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "completedIndicatorTemplate", first: true, predicate: IgxStepCompletedIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "activeIndicatorTemplate", first: true, predicate: IgxStepActiveIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "_steps", predicate: IgxStepComponent }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-stepper', providers: [
                        IgxStepperService,
                        { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
                    ], template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i1.IgxStepperService }, { type: i0.ElementRef }]; }, propDecorators: { verticalAnimationType: [{
                type: Input
            }], horizontalAnimationType: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], linear: [{
                type: Input
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }, {
                type: Input
            }], stepType: [{
                type: Input
            }], contentTop: [{
                type: Input
            }], titlePosition: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-stepper']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], directionClass: [{
                type: HostBinding,
                args: ['class.igx-stepper--horizontal']
            }], activeStepChanging: [{
                type: Output
            }], activeStepChanged: [{
                type: Output
            }], invalidIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepInvalidIndicatorDirective, { read: TemplateRef }]
            }], completedIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepCompletedIndicatorDirective, { read: TemplateRef }]
            }], activeIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepActiveIndicatorDirective, { read: TemplateRef }]
            }], _steps: [{
                type: ContentChildren,
                args: [IgxStepComponent, { descendants: false }]
            }] } });
export class IgxStepperModule {
}
IgxStepperModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IgxStepperModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperModule, declarations: [IgxStepComponent, IgxStepperComponent, IgxStepTitleDirective,
        IgxStepSubTitleDirective,
        IgxStepIndicatorDirective,
        IgxStepContentDirective,
        IgxStepActiveIndicatorDirective,
        IgxStepCompletedIndicatorDirective,
        IgxStepInvalidIndicatorDirective], imports: [CommonModule,
        IgxRippleModule], exports: [IgxStepComponent, IgxStepperComponent, IgxStepTitleDirective,
        IgxStepSubTitleDirective,
        IgxStepIndicatorDirective,
        IgxStepContentDirective,
        IgxStepActiveIndicatorDirective,
        IgxStepCompletedIndicatorDirective,
        IgxStepInvalidIndicatorDirective] });
IgxStepperModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperModule, imports: [CommonModule,
        IgxRippleModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxStepperModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IgxRippleModule
                    ],
                    declarations: [
                        IgxStepComponent,
                        IgxStepperComponent,
                        IgxStepTitleDirective,
                        IgxStepSubTitleDirective,
                        IgxStepIndicatorDirective,
                        IgxStepContentDirective,
                        IgxStepActiveIndicatorDirective,
                        IgxStepCompletedIndicatorDirective,
                        IgxStepInvalidIndicatorDirective,
                    ],
                    exports: [
                        IgxStepComponent,
                        IgxStepperComponent,
                        IgxStepTitleDirective,
                        IgxStepSubTitleDirective,
                        IgxStepIndicatorDirective,
                        IgxStepContentDirective,
                        IgxStepActiveIndicatorDirective,
                        IgxStepCompletedIndicatorDirective,
                        IgxStepInvalidIndicatorDirective,
                    ]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUE4QixZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNrQyxTQUFTLEVBQUUsWUFBWSxFQUFFLGVBQWUsRUFDakUsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFDdEQsTUFBTSxFQUEyQixXQUFXLEVBQ3ZELE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDM0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzVDLE9BQU8sRUFBMkIsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM5RixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFFeEUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0saURBQWlELENBQUM7QUFFN0YsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDekQsT0FBTyxFQUNTLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFLFdBQVcsRUFDdkUscUJBQXFCLEVBQWlE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IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLCB1c2VBbmltYXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLFxuICAgIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE5nTW9kdWxlLCBPbkNoYW5nZXMsIE9uRGVzdHJveSxcbiAgICBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnLi4vYW5pbWF0aW9ucy9ncm93JztcbmltcG9ydCB7IGZhZGVJbiB9IGZyb20gJy4uL2FuaW1hdGlvbnMvbWFpbic7XG5pbXBvcnQgeyBIb3Jpem9udGFsQW5pbWF0aW9uVHlwZSwgSWd4Q2Fyb3VzZWxDb21wb25lbnRCYXNlIH0gZnJvbSAnLi4vY2Fyb3VzZWwvY2Fyb3VzZWwtYmFzZSc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVNb2R1bGUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzIH0gZnJvbSAnLi4vZXhwYW5zaW9uLXBhbmVsL3RvZ2dsZS1hbmltYXRpb24tY29tcG9uZW50JztcbmltcG9ydCB7IElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuZ3VsYXItYW5pbWF0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmltYXRpb24nO1xuaW1wb3J0IHsgSWd4U3RlcENvbXBvbmVudCB9IGZyb20gJy4vc3RlcC9zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIElneFN0ZXBwZXIsIElneFN0ZXBwZXJPcmllbnRhdGlvbiwgSWd4U3RlcHBlclRpdGxlUG9zaXRpb24sIElneFN0ZXBUeXBlLFxuICAgIElHWF9TVEVQUEVSX0NPTVBPTkVOVCwgSVN0ZXBDaGFuZ2VkRXZlbnRBcmdzLCBJU3RlcENoYW5naW5nRXZlbnRBcmdzLCBWZXJ0aWNhbEFuaW1hdGlvblR5cGVcbn0gZnJvbSAnLi9zdGVwcGVyLmNvbW1vbic7XG5pbXBvcnQge1xuICAgIElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICBJZ3hTdGVwQ29udGVudERpcmVjdGl2ZSxcbiAgICBJZ3hTdGVwSW5kaWNhdG9yRGlyZWN0aXZlLCBJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICBJZ3hTdGVwU3ViVGl0bGVEaXJlY3RpdmUsIElneFN0ZXBUaXRsZURpcmVjdGl2ZVxufSBmcm9tICcuL3N0ZXBwZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFN0ZXBwZXJTZXJ2aWNlIH0gZnJvbSAnLi9zdGVwcGVyLnNlcnZpY2UnO1xuXG5cbi8vIFRPRE86IGNvbW1vbiBpbnRlcmZhY2UgYmV0d2VlbiBJZ3hDYXJvdXNlbENvbXBvbmVudEJhc2UgYW5kIFRvZ2dsZUFuaW1hdGlvblBsYXllcj9cblxuLyoqXG4gKiBJZ3hTdGVwcGVyIHByb3ZpZGVzIGEgd2l6YXJkLWxpa2Ugd29ya2Zsb3cgYnkgZGl2aWRpbmcgY29udGVudCBpbnRvIGxvZ2ljYWwgc3RlcHMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTdGVwcGVyTW9kdWxlXG4gKlxuICogQGlneEtleXdvcmRzIHN0ZXBwZXJcbiAqXG4gKiBAaWd4R3JvdXAgTGF5b3V0c1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFN0ZXBwZXIgY29tcG9uZW50IGFsbG93cyB0aGUgdXNlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIG11bHRpcGxlIHN0ZXBzLlxuICogSXQgc3VwcG9ydHMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgb3JpZW50YXRpb24gYXMgd2VsbCBhcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBwcm92aWRlcyBBUEkgbWV0aG9kcyB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqIFRoZSBjb21wb25lbnQgb2ZmZXJzIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIEFQSSB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zdGVwcGVyPlxuICogIDxpZ3gtc3RlcCBbYWN0aXZlXT1cInRydWVcIj5cbiAqICAgICAgPGlneC1pY29uIGlneFN0ZXBJbmRpY2F0b3I+aG9tZTwvaWd4LWljb24+XG4gKiAgICAgIDxwIGlneFN0ZXBUaXRsZT5Ib21lPC9wPlxuICogICAgICA8ZGl2IGlneFN0ZXBDb250ZW50PlxuICogICAgICAgICAuLi5cbiAqICAgICAgPC9kaXY+XG4gKiAgPC9pZ3gtc3RlcD5cbiAqICA8aWd4LXN0ZXAgW29wdGlvbmFsXT1cInRydWVcIj5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogIDxpZ3gtc3RlcD5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogPC9pZ3gtc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hTdGVwcGVyU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfU1RFUFBFUl9DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBJZ3hTdGVwcGVyQ29tcG9uZW50IH0sXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTdGVwcGVyQ29tcG9uZW50IGV4dGVuZHMgSWd4Q2Fyb3VzZWxDb21wb25lbnRCYXNlIGltcGxlbWVudHMgSWd4U3RlcHBlciwgT25DaGFuZ2VzLCBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBhbmltYXRpb24gdHlwZSBvZiB0aGUgc3RlcHBlciB3aGVuIHRoZSBvcmllbnRhdGlvbiBkaXJlY3Rpb24gaXMgdmVydGljYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGdyb3dgLiBPdGhlciBwb3NzaWJsZSB2YWx1ZXMgYXJlIGBmYWRlYCBhbmQgYG5vbmVgLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciB2ZXJ0aWNhbEFuaW1hdGlvblR5cGU9XCJub25lXCI+XG4gICAgICogPGlneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB2ZXJ0aWNhbEFuaW1hdGlvblR5cGUoKTogVmVydGljYWxBbmltYXRpb25UeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHZlcnRpY2FsQW5pbWF0aW9uVHlwZSh2YWx1ZTogVmVydGljYWxBbmltYXRpb25UeXBlKSB7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZUNoYW5nZSBldmVudCBpcyBub3QgZW1pdHRlZCBmb3IgdGhlIGNvbGxhcHNpbmcgc3RlcHMgKGxvb3AgdGhyb3VnaCBjb2xsYXBzaW5nIHN0ZXBzIGFuZCBlbWl0KVxuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbEFuaW1hdGlvblR5cGUgPSB2YWx1ZTtcblxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdncm93JzpcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MgPSB0aGlzLnVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MoZ3Jvd1ZlckluLCBncm93VmVyT3V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhZGUnOlxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25TZXR0aW5ncyA9IHRoaXMudXBkYXRlVmVydGljYWxBbmltYXRpb25TZXR0aW5ncyhmYWRlSW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzID0gdGhpcy51cGRhdGVWZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgYW5pbWF0aW9uIHR5cGUgb2YgdGhlIHN0ZXBwZXIgd2hlbiB0aGUgb3JpZW50YXRpb24gZGlyZWN0aW9uIGlzIGhvcml6b250YWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGdyb3dgLiBPdGhlciBwb3NzaWJsZSB2YWx1ZXMgYXJlIGBmYWRlYCBhbmQgYG5vbmVgLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciBhbmltYXRpb25UeXBlPVwibm9uZVwiPlxuICAgICAqIDxpZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaG9yaXpvbnRhbEFuaW1hdGlvblR5cGUoKTogSG9yaXpvbnRhbEFuaW1hdGlvblR5cGUge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25UeXBlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgaG9yaXpvbnRhbEFuaW1hdGlvblR5cGUodmFsdWU6IEhvcml6b250YWxBbmltYXRpb25UeXBlKSB7XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZUNoYW5nZSBldmVudCBpcyBub3QgZW1pdHRlZCBmb3IgdGhlIGNvbGxhcHNpbmcgc3RlcHMgKGxvb3AgdGhyb3VnaCBjb2xsYXBzaW5nIHN0ZXBzIGFuZCBlbWl0KVxuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblR5cGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBhbmltYXRpb24gZHVyYXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciBbYW5pbWF0aW9uRHVyYXRpb25dPVwiNTAwXCI+XG4gICAgICogPGlneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBhbmltYXRpb25EdXJhdGlvbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QW5pbWF0aW9uRHVyYXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBhbmltYXRpb25EdXJhdGlvbih2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0QW5pbWF0aW9uRHVyYXRpb24gPSB0aGlzLl9kZWZhdWx0QW5pbWF0aW9uRHVyYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB3aGV0aGVyIHRoZSBzdGVwcGVyIGlzIGxpbmVhci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlIHN0ZXBwZXIgaXMgaW4gbGluZWFyIG1vZGUgYW5kIGlmIHRoZSBhY3RpdmUgc3RlcCBpcyB2YWxpZCBvbmx5IHRoZW4gdGhlIHVzZXIgaXMgYWJsZSB0byBtb3ZlIGZvcndhcmQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zdGVwcGVyIFtsaW5lYXJdPVwidHJ1ZVwiPjwvaWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGxpbmVhcigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVhcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGxpbmVhcih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9saW5lYXIgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVhciAmJiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHN0ZXBwZXIgaXMgaW4gbGluZWFyIG1vZGUgd2Ugc2hvdWxkIGNhbGN1bGF0ZSB3aGljaCBzdGVwcyBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICAgICAgICAgIC8vIGFuZCB3aGljaCBhcmUgdmlzaXRlZCBpLmUuIHRoZWlyIHZhbGlkaXR5IHNob3VsZCBiZSBjb3JyZWN0bHkgZGlzcGxheWVkLlxuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVWaXNpdGVkU3RlcHMoKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY2FsY3VsYXRlTGluZWFyRGlzYWJsZWRTdGVwcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5saW5lYXJEaXNhYmxlZFN0ZXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBzdGVwcGVyIG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5vcmllbnRhdGlvbiA9IElneFN0ZXBwZXJPcmllbnRhdGlvbi5WZXJ0aWNhbDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vcmllbnRhdGlvbicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG9yaWVudGF0aW9uKCk6IElneFN0ZXBwZXJPcmllbnRhdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IG9yaWVudGF0aW9uKHZhbHVlOiBJZ3hTdGVwcGVyT3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWN0aXZlQ2hhbmdlIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvciB0aGUgY29sbGFwc2luZyBzdGVwc1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGl0bGVQb3NpdGlvbiA9IHRoaXMuX29yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbCA/XG4gICAgICAgICAgICBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Cb3R0b20gOiBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5FbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgdHlwZSBvZiB0aGUgc3RlcHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnN0ZXBUeXBlID0gSWd4U3RlcFR5cGUuSW5kaWNhdG9yO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN0ZXBUeXBlOiBJZ3hTdGVwVHlwZSA9IElneFN0ZXBUeXBlLkZ1bGw7XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHdoZXRoZXIgdGhlIGNvbnRlbnQgaXMgZGlzcGxheWVkIGFib3ZlIHRoZSBzdGVwcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgIGFuZCB0aGUgY29udGVudCBpcyBiZWxvdyB0aGUgc3RlcHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLmNvbnRlbnRUb3AgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbnRlbnRUb3AgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdGVwcyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgd2hlbiB0aGUgc3RlcHBlciBpcyBob3Jpem9udGFsbHkgb3JpZW50YXRlZCBpcyBgYm90dG9tYC5cbiAgICAgKiBJbiB2ZXJ0aWNhbCBsYXlvdXQgdGhlIGRlZmF1bHQgdGl0bGUgcG9zaXRpb24gaXMgYGVuZGAuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnRpdGxlUG9zaXRpb24gPSBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Ub3A7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGl0bGVQb3NpdGlvbjogSWd4U3RlcHBlclRpdGxlUG9zaXRpb24gPSBudWxsO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXN0ZXBwZXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtc3RlcHBlcic7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3RhYmxpc3QnO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXN0ZXBwZXItLWhvcml6b250YWwnKVxuICAgIHB1YmxpYyBnZXQgZGlyZWN0aW9uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHN0ZXBwZXIncyBhY3RpdmUgc3RlcCBpcyBjaGFuZ2luZy5cbiAgICAgKlxuICAgICAqYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciAoYWN0aXZlU3RlcENoYW5naW5nKT1cImhhbmRsZUFjdGl2ZVN0ZXBDaGFuZ2luZygkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVBY3RpdmVTdGVwQ2hhbmdpbmcoZXZlbnQ6IElTdGVwQ2hhbmdpbmdFdmVudEFyZ3MpIHtcbiAgICAgKiAgaWYgKGV2ZW50Lm5ld0luZGV4IDwgZXZlbnQub2xkSW5kZXgpIHtcbiAgICAgKiAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYWN0aXZlU3RlcENoYW5naW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJU3RlcENoYW5naW5nRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBhY3RpdmUgc3RlcCBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiA8aWd4LXN0ZXBwZXIgKGFjdGl2ZVN0ZXBDaGFuZ2VkKT1cImhhbmRsZUFjdGl2ZVN0ZXBDaGFuZ2VkKCRldmVudClcIj48L2lneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBhY3RpdmVTdGVwQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVN0ZXBDaGFuZ2VkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBpbnZhbGlkSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBJbnZhbGlkSW5kaWNhdG9yRGlyZWN0aXZlPjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBjb21wbGV0ZWRJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZT47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkKElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgYWN0aXZlSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmU+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTdGVwQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICAgIHByaXZhdGUgX3N0ZXBzOiBRdWVyeUxpc3Q8SWd4U3RlcENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHN0ZXBzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHN0ZXBzOiBJZ3hTdGVwQ29tcG9uZW50W10gPSB0aGlzLnN0ZXBwZXIuc3RlcHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGVwcygpOiBJZ3hTdGVwQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcHM/LnRvQXJyYXkoKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3M6IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzID0ge1xuICAgICAgICBvcGVuQW5pbWF0aW9uOiBncm93VmVySW4sXG4gICAgICAgIGNsb3NlQW5pbWF0aW9uOiBncm93VmVyT3V0LFxuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIF9kZWZhdWx0VGl0bGVQb3NpdGlvbjogSWd4U3RlcHBlclRpdGxlUG9zaXRpb24gPSBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Cb3R0b207XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgcHJpdmF0ZSBfb3JpZW50YXRpb246IElneFN0ZXBwZXJPcmllbnRhdGlvbiA9IElneFN0ZXBwZXJPcmllbnRhdGlvbi5Ib3Jpem9udGFsO1xuICAgIHByaXZhdGUgX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZTogVmVydGljYWxBbmltYXRpb25UeXBlID0gVmVydGljYWxBbmltYXRpb25UeXBlLkdyb3c7XG4gICAgcHJpdmF0ZSBfbGluZWFyID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uID0gMzUwO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UpIGFuaW1hdGlvblNlcnZpY2U6IEFuaW1hdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgc3RlcHBlclNlcnZpY2U6IElneFN0ZXBwZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7XG4gICAgICAgIHN1cGVyKGFuaW1hdGlvblNlcnZpY2UsIGNkcik7XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2Uuc3RlcHBlciA9IHRoaXM7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2FuaW1hdGlvbkR1cmF0aW9uJ10pIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25UeXBlID0gdGhpcy5fdmVydGljYWxBbmltYXRpb25UeXBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVudGVyQW5pbWF0aW9uRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcENoYW5nZWQuZW1pdCh7IG93bmVyOiB0aGlzLCBpbmRleDogdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwLmluZGV4IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWF2ZUFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2UodGhpcy5zdGVwcGVyU2VydmljZS5wcmV2aW91c0FjdGl2ZVN0ZXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzKS5zbGljZSgwLCB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5zaXplIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goc3RlcCA9PiB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNlKHN0ZXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGxldCBhY3RpdmVTdGVwO1xuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0ZXBBcmlhKHN0ZXAsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlU3RlcCAmJiBzdGVwLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhY3RpdmVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlRmlyc3RTdGVwKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVTdGVwQ2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHN0ZXAgYXQgYSBnaXZlbiBpbmRleC5cbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5uYXZpZ2F0ZVRvKDEpO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlVG8oaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5zdGVwc1tpbmRleF07XG4gICAgICAgIGlmICghc3RlcCB8fCB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXAgPT09IHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlU3RlcChzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIG5leHQgZW5hYmxlZCBzdGVwLlxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLm5leHQoKTtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vdmVUb05leHRTdGVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBwcmV2aW91cyBlbmFibGVkIHN0ZXAuXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIucHJldigpO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHByZXYoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZVRvTmV4dFN0ZXAoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3RlcHBlciB0byBpdHMgaW5pdGlhbCBzdGF0ZSBpLmUuIGFjdGl2YXRlcyB0aGUgZmlyc3Qgc3RlcC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIHN0ZXBzJyBjb250ZW50IHdpbGwgbm90IGJlIGF1dG9tYXRpY2FsbHkgcmVzZXQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnJlc2V0KCk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UudmlzaXRlZFN0ZXBzLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVN0ZXAgPSB0aGlzLnN0ZXBzLmZpbmQocyA9PiAhcy5kaXNhYmxlZCk7XG4gICAgICAgIGlmIChhY3RpdmVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlU3RlcChhY3RpdmVTdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBwbGF5SG9yaXpvbnRhbEFuaW1hdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucHJldmlvdXNJdGVtID0gdGhpcy5zdGVwcGVyU2VydmljZS5wcmV2aW91c0FjdGl2ZVN0ZXA7XG4gICAgICAgIHRoaXMuY3VycmVudEl0ZW0gPSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXA7XG4gICAgICAgIHRoaXMudHJpZ2dlckFuaW1hdGlvbnMoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0UHJldmlvdXNFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHBlclNlcnZpY2UucHJldmlvdXNBY3RpdmVTdGVwPy5jb250ZW50Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEN1cnJlbnRFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcC5jb250ZW50Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzKFxuICAgICAgICBvcGVuQW5pbWF0aW9uOiBBbmltYXRpb25SZWZlcmVuY2VNZXRhZGF0YSxcbiAgICAgICAgY2xvc2VBbmltYXRpb246IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhKTogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3Mge1xuICAgICAgICBjb25zdCBjdXN0b21DbG9zZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbihjbG9zZUFuaW1hdGlvbiwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gKyAnbXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXN0b21PcGVuQW5pbWF0aW9uID0gdXNlQW5pbWF0aW9uKG9wZW5BbmltYXRpb24sIHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uICsgJ21zJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BlbkFuaW1hdGlvbjogb3BlbkFuaW1hdGlvbiA/IGN1c3RvbU9wZW5BbmltYXRpb24gOiBudWxsLFxuICAgICAgICAgICAgY2xvc2VBbmltYXRpb246IGNsb3NlQW5pbWF0aW9uID8gY3VzdG9tQ2xvc2VBbmltYXRpb24gOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGVwQXJpYShzdGVwOiBJZ3hTdGVwQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN0ZXAuX2luZGV4ID0gaW5kZXg7XG4gICAgICAgIHN0ZXAucmVuZGVyZXIuc2V0QXR0cmlidXRlKHN0ZXAubmF0aXZlRWxlbWVudCwgJ2FyaWEtc2V0c2l6ZScsICh0aGlzLnN0ZXBzLmxlbmd0aCkudG9TdHJpbmcoKSk7XG4gICAgICAgIHN0ZXAucmVuZGVyZXIuc2V0QXR0cmlidXRlKHN0ZXAubmF0aXZlRWxlbWVudCwgJ2FyaWEtcG9zaW5zZXQnLCAoaW5kZXggKyAxKS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZVN0ZXBDaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdGVwcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoc3RlcHMgPT4ge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGVwQXJpYShzdGVwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBhY3RpdmUgc3RlcCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzQWN0aXZlU3RlcCA9IHRoaXMuc3RlcHMuZmluZChzID0+IHMgPT09IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY3RpdmVTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVGaXJzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE8gRE86IG1hcmsgc3RlcCBhZGRlZCBiZWZvcmUgdGhlIGFjdGl2ZSBhcyB2aXNpdGVkP1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVhcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNhbGN1bGF0ZUxpbmVhckRpc2FibGVkU3RlcHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZUZpcnN0U3RlcChhY3RpdmF0ZUluaXRpYWxseSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RW5hYmxlZFN0ZXAgPSB0aGlzLnN0ZXBzLmZpbmQocyA9PiAhcy5kaXNhYmxlZCk7XG4gICAgICAgIGlmIChmaXJzdEVuYWJsZWRTdGVwKSB7XG4gICAgICAgICAgICBmaXJzdEVuYWJsZWRTdGVwLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYWN0aXZhdGVJbml0aWFsbHkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEVuYWJsZWRTdGVwLmFjdGl2ZUNoYW5nZS5lbWl0KHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcENoYW5nZWQuZW1pdCh7IG93bmVyOiB0aGlzLCBpbmRleDogZmlyc3RFbmFibGVkU3RlcC5pbmRleCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWN0aXZhdGVTdGVwKHN0ZXA6IElneFN0ZXBDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09IElneFN0ZXBwZXJPcmllbnRhdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICBzdGVwLmNoYW5nZUhvcml6b250YWxBY3RpdmVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmV4cGFuZChzdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZVRvTmV4dFN0ZXAobmV4dCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHN0ZXBzOiBJZ3hTdGVwQ29tcG9uZW50W10gPSB0aGlzLnN0ZXBzO1xuICAgICAgICBsZXQgYWN0aXZlU3RlcEluZGV4ID0gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwLmluZGV4O1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIHN0ZXBzID0gdGhpcy5zdGVwcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBhY3RpdmVTdGVwSW5kZXggPSBzdGVwcy5maW5kSW5kZXgocyA9PiBzID09PSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dFN0ZXAgPSBzdGVwcy5maW5kKChzLCBpKSA9PiBpID4gYWN0aXZlU3RlcEluZGV4ICYmIHMuaXNBY2Nlc3NpYmxlKTtcbiAgICAgICAgaWYgKG5leHRTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlU3RlcChuZXh0U3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIElneFJpcHBsZU1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIElneFN0ZXBDb21wb25lbnQsXG4gICAgICAgIElneFN0ZXBwZXJDb21wb25lbnQsXG4gICAgICAgIElneFN0ZXBUaXRsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcFN1YlRpdGxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hTdGVwSW5kaWNhdG9yRGlyZWN0aXZlLFxuICAgICAgICBJZ3hTdGVwQ29udGVudERpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcEFjdGl2ZUluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIElneFN0ZXBDb21wb25lbnQsXG4gICAgICAgIElneFN0ZXBwZXJDb21wb25lbnQsXG4gICAgICAgIElneFN0ZXBUaXRsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcFN1YlRpdGxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hTdGVwSW5kaWNhdG9yRGlyZWN0aXZlLFxuICAgICAgICBJZ3hTdGVwQ29udGVudERpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcEFjdGl2ZUluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICAgICAgSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTdGVwcGVyTW9kdWxlIHsgfVxuIiwiPGRpdiAqbmdJZj1cIiFjb250ZW50VG9wIHx8IG9yaWVudGF0aW9uICE9PSAnaG9yaXpvbnRhbCdcIiBjbGFzcz1cImlneC1zdGVwcGVyX19oZWFkZXJcIj5cbiAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwVGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxuPC9kaXY+XG5cbjxkaXYgKm5nSWY9XCJvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnXCIgY2xhc3M9XCJpZ3gtc3RlcHBlcl9fYm9keVwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHN0ZXAgb2Ygc3RlcHNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInN0ZXAuY29udGVudFRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cblxuPGRpdiAqbmdJZj1cImNvbnRlbnRUb3AgJiYgb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJ1wiIGNsYXNzPVwiaWd4LXN0ZXBwZXJfX2hlYWRlclwiPlxuICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cInN0ZXBUZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNzdGVwVGVtcGxhdGU+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXN0ZXBcIj48L25nLWNvbnRlbnQ+XG48L25nLXRlbXBsYXRlPlxuIl19