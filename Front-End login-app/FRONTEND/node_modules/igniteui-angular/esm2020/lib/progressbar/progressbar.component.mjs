import { CommonModule } from '@angular/common';
import { Component, EventEmitter, HostBinding, Input, NgModule, Output, ViewChild, ContentChild, Directive } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { mkenum } from '../core/utils';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../services/direction/directionality";
const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
export const IgxTextAlign = mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
export const IgxProgressType = mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
export class BaseProgressDirective {
    constructor() {
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.progressChanged = new EventEmitter();
        /**
         * Sets/Gets progressbar in indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/Gets progressbar animation duration. By default it is 2000ms.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.animationDuration = 2000;
        this._initValue = 0;
        this._contentInit = false;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        this._internalState = {
            oldVal: 0,
            newVal: 0
        };
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        const step = Number(val);
        if (step > this.max) {
            return;
        }
        this._step = step;
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
        if (animate) {
            this.animationDuration = 2000;
        }
        else {
            this.animationDuration = 0;
        }
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        if (maxNum < MIN_VALUE || this._max === maxNum ||
            (this._animation && this._animation.playState !== 'finished')) {
            return;
        }
        this._internalState.newVal = Math.round(toValue(toPercent(this.value, maxNum), maxNum));
        this._value = this._internalState.oldVal = Math.round(toValue(this.valueInPercent, maxNum));
        this._max = maxNum;
        this.triggerProgressTransition(this._internalState.oldVal, this._internalState.newVal, true);
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        const val = toPercent(this._value, this._max);
        return val;
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        if (this._animation && this._animation.playState !== 'finished' || val < 0) {
            return;
        }
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    triggerProgressTransition(oldVal, newVal, maxUpdate = false) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            const newToPercent = toPercent(newVal, this.max);
            const oldToPercent = toPercent(oldVal, this.max);
            const duration = this.animationDuration / Math.abs(newToPercent - oldToPercent) / (this._step ? this._step : 1);
            this.runAnimation(newVal);
            this._interval = setInterval(() => this.increase(newVal, stepDirection), duration);
        }
        else {
            this.updateProgress(newVal);
        }
        if (maxUpdate) {
            return;
        }
        this.progressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    increase(newValue, step) {
        const targetValue = toPercent(newValue, this._max);
        this._value = valueInRange(this._value, this._max) + step;
        if ((step > 0 && this.valueInPercent >= targetValue) || (step < 0 && this.valueInPercent <= targetValue)) {
            if (this._value !== newValue) {
                this._value = newValue;
            }
            return clearInterval(this._interval);
        }
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        // this.valueInPercent = toPercent(val, this._max);
        this.runAnimation(val);
    }
}
BaseProgressDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: BaseProgressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
BaseProgressDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.0", type: BaseProgressDirective, inputs: { indeterminate: "indeterminate", animationDuration: "animationDuration", step: "step", animate: "animate", max: "max", value: "value" }, outputs: { progressChanged: "progressChanged" }, host: { properties: { "attr.aria-valuemax": "this.max", "attr.aria-valuenow": "this.value" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: BaseProgressDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return []; }, propDecorators: { progressChanged: [{
                type: Output
            }], indeterminate: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], step: [{
                type: Input
            }], animate: [{
                type: Input
            }], max: [{
                type: HostBinding,
                args: ['attr.aria-valuemax']
            }, {
                type: Input
            }], value: [{
                type: HostBinding,
                args: ['attr.aria-valuenow']
            }, {
                type: Input
            }] } });
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super(...arguments);
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        this.animationState = {
            width: '0%'
        };
    }
    /**
     * @hidden
     * ```
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = {
            ...this.animationState
        };
        this.animationState.width = valueInPercent + '%';
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._progressIndicator.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
}
IgxLinearProgressBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxLinearProgressBarComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
IgxLinearProgressBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxLinearProgressBarComponent, selector: "igx-linear-bar", inputs: { striped: "striped", role: "role", id: "id", textAlign: "textAlign", textVisibility: "textVisibility", textTop: "textTop", text: "text", type: "type" }, host: { properties: { "attr.aria-valuemin": "this.valueMin", "class.igx-linear-bar": "this.cssClass", "class.igx-linear-bar--striped": "this.striped", "class.igx-linear-bar--indeterminate": "this.isIndeterminate", "attr.role": "this.role", "attr.id": "this.id", "class.igx-linear-bar--danger": "this.error", "class.igx-linear-bar--info": "this.info", "class.igx-linear-bar--warning": "this.warning", "class.igx-linear-bar--success": "this.success" } }, viewQueries: [{ propertyName: "_progressIndicator", first: true, predicate: ["indicator"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n", dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxLinearProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-linear-bar', template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n" }]
        }], propDecorators: { valueMin: [{
                type: HostBinding,
                args: ['attr.aria-valuemin']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-linear-bar']
            }], striped: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--striped']
            }, {
                type: Input
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--indeterminate']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], textAlign: [{
                type: Input
            }], textVisibility: [{
                type: Input
            }], textTop: [{
                type: Input
            }], text: [{
                type: Input
            }], type: [{
                type: Input
            }], _progressIndicator: [{
                type: ViewChild,
                args: ['indicator', { static: true }]
            }], error: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--danger']
            }], info: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--info']
            }], warning: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--warning']
            }], success: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--success']
            }] } });
export class IgxCircularProgressBarComponent extends BaseProgressDirective {
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        this.animationState = {
            strokeDashoffset: 289,
            strokeOpacity: 1
        };
    }
    /**
     * @hidden
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = { ...this.animationState };
        this.animationState.strokeDashoffset = this.getProgress(valueInPercent);
        this.animationState.strokeOpacity = toPercent(value, this.max) / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION;
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxCircularProgressBarComponent, deps: [{ token: i0.Renderer2 }, { token: i2.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component });
IgxCircularProgressBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: { id: "id", isIndeterminate: "isIndeterminate", textVisibility: "textVisibility", text: "text" }, host: { properties: { "class.igx-circular-bar": "this.cssClass", "attr.id": "this.id", "class.igx-circular-bar--indeterminate": "this.isIndeterminate" } }, queries: [{ propertyName: "textTemplate", first: true, predicate: IgxProcessBarTextTemplateDirective, descendants: true, read: IgxProcessBarTextTemplateDirective }, { propertyName: "gradientTemplate", first: true, predicate: IgxProgressBarGradientDirective, descendants: true, read: IgxProgressBarGradientDirective }], viewQueries: [{ propertyName: "_svgCircle", first: true, predicate: ["circle"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n", dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxCircularProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-circular-bar', template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n" }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i2.IgxDirectionality }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-circular-bar']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-circular-bar--indeterminate']
            }, {
                type: Input
            }], textVisibility: [{
                type: Input
            }], text: [{
                type: Input
            }], textTemplate: [{
                type: ContentChild,
                args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective }]
            }], gradientTemplate: [{
                type: ContentChild,
                args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
            }], _svgCircle: [{
                type: ViewChild,
                args: ['circle', { static: true }]
            }] } });
export const valueInRange = (value, max, min = 0) => Math.max(Math.min(value, max), min);
export const toPercent = (value, max) => !max ? 0 : Math.floor(100 * value / max);
export const toValue = (value, max) => max * value / 100;
/**
 * @hidden
 */
export class IgxProgressBarModule {
}
IgxProgressBarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxProgressBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IgxProgressBarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: IgxProgressBarModule, declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective], imports: [CommonModule], exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective] });
IgxProgressBarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxProgressBarModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: IgxProgressBarModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        IgxLinearProgressBarComponent,
                        IgxCircularProgressBarComponent,
                        IgxProcessBarTextTemplateDirective,
                        IgxProgressBarGradientDirective,
                    ],
                    exports: [
                        IgxLinearProgressBarComponent,
                        IgxCircularProgressBarComponent,
                        IgxProcessBarTextTemplateDirective,
                        IgxProgressBarGradientDirective,
                    ],
                    imports: [CommonModule]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvY2lyY3VsYXItYmFyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ0gsU0FBUyxFQUVULFlBQVksRUFDWixXQUFXLEVBQ1gsS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBRU4sU0FBUyxFQUNULFlBQVksRUFHWixTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNILGtDQUFrQyxFQUNsQywrQkFBK0IsR0FDbEMsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQWtCLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQUV2RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXBCLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUM7SUFDL0IsS0FBSyxFQUFFLE9BQU87SUFDZCxNQUFNLEVBQUUsUUFBUTtJQUNoQixHQUFHLEVBQUUsS0FBSztDQUNiLENBQUMsQ0FBQztBQUdILE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUM7SUFDbEMsS0FBSyxFQUFFLE9BQU87SUFDZCxJ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b0JBQW9COztpSEFBcEIsb0JBQW9CO2tIQUFwQixvQkFBb0IsaUJBMVVwQiw2QkFBNkIsRUE0SzdCLCtCQUErQixFQW1KcEMsa0NBQWtDO1FBQ2xDLCtCQUErQixhQVF6QixZQUFZLGFBeFViLDZCQUE2QixFQTRLN0IsK0JBQStCLEVBeUpwQyxrQ0FBa0M7UUFDbEMsK0JBQStCO2tIQUkxQixvQkFBb0IsWUFGbkIsWUFBWTsyRkFFYixvQkFBb0I7a0JBZmhDLFFBQVE7bUJBQUM7b0JBQ04sWUFBWSxFQUFFO3dCQUNWLDZCQUE2Qjt3QkFDN0IsK0JBQStCO3dCQUMvQixrQ0FBa0M7d0JBQ2xDLCtCQUErQjtxQkFDbEM7b0JBQ0QsT0FBTyxFQUFFO3dCQUNMLDZCQUE2Qjt3QkFDN0IsK0JBQStCO3dCQUMvQixrQ0FBa0M7d0JBQ2xDLCtCQUErQjtxQkFDbEM7b0JBQ0QsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDO2lCQUMxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIERpcmVjdGl2ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxufSBmcm9tICcuL3Byb2dyZXNzYmFyLmNvbW1vbic7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncywgbWtlbnVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5jb25zdCBPTkVfUEVSQ0VOVCA9IDAuMDE7XG5jb25zdCBNSU5fVkFMVUUgPSAwO1xuXG5leHBvcnQgY29uc3QgSWd4VGV4dEFsaWduID0gbWtlbnVtKHtcbiAgICBTVEFSVDogJ3N0YXJ0JyxcbiAgICBDRU5URVI6ICdjZW50ZXInLFxuICAgIEVORDogJ2VuZCdcbn0pO1xuZXhwb3J0IHR5cGUgSWd4VGV4dEFsaWduID0gKHR5cGVvZiBJZ3hUZXh0QWxpZ24pW2tleW9mIHR5cGVvZiBJZ3hUZXh0QWxpZ25dO1xuXG5leHBvcnQgY29uc3QgSWd4UHJvZ3Jlc3NUeXBlID0gbWtlbnVtKHtcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgICBJTkZPOiAnaW5mbycsXG4gICAgV0FSTklORzogJ3dhcm5pbmcnLFxuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJ1xufSk7XG5leHBvcnQgdHlwZSBJZ3hQcm9ncmVzc1R5cGUgPSAodHlwZW9mIElneFByb2dyZXNzVHlwZSlba2V5b2YgdHlwZW9mIElneFByb2dyZXNzVHlwZV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IG51bWJlcjtcbiAgICBjdXJyZW50VmFsdWU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0NoYW5nZShldmVudCkge1xuICAgICAqICAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqIH1cbiAgICAgKiAgLy8uLi5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChwcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChwcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHByb2dyZXNzQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9HZXRzIHByb2dyZXNzYmFyIGluIGluZGV0ZXJtaW5hdGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgcHJvZ3Jlc3NiYXIgYW5pbWF0aW9uIGR1cmF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIDIwMDBtcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGlvbkR1cmF0aW9uID0gMjAwMDtcbiAgICBwdWJsaWMgX2ludGVydmFsO1xuXG4gICAgcHJvdGVjdGVkIF9pbml0VmFsdWUgPSAwO1xuICAgIHByb3RlY3RlZCBfY29udGVudEluaXQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX21heCA9IDEwMDtcbiAgICBwcm90ZWN0ZWQgX3ZhbHVlID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfbmV3VmFsID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0ZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIF9zdGVwO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0aW9uO1xuICAgIHByb3RlY3RlZCBfdmFsdWVJblBlcmNlbnQ7XG4gICAgcHJvdGVjdGVkIF9pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICBvbGRWYWw6IDAsXG4gICAgICAgIG5ld1ZhbDogMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBwcm9ncmVzcyBiYXJgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5wcm9ncmVzc0Jhci5zdGVwO1xuICAgICAqICAgICBhbGVydChzdGVwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBzdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChzdGVwID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGluZyB0aGUgcHJvZ3Jlc3MuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gMjAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBgcHJvZ3Jlc3MgYmFyYCBoYXMgYW5pbWF0aW9uIHRydWUvZmFsc2UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBhbmltYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKG1heE51bSA8IE1JTl9WQUxVRSB8fCB0aGlzLl9tYXggPT09IG1heE51bSB8fFxuICAgICAgICAgICAgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW50ZXJuYWxTdGF0ZS5uZXdWYWwgPSBNYXRoLnJvdW5kKHRvVmFsdWUodG9QZXJjZW50KHRoaXMudmFsdWUsIG1heE51bSksIG1heE51bSkpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2ludGVybmFsU3RhdGUub2xkVmFsID0gTWF0aC5yb3VuZCh0b1ZhbHVlKHRoaXMudmFsdWVJblBlcmNlbnQsIG1heE51bSkpO1xuICAgICAgICB0aGlzLl9tYXggPSBtYXhOdW07XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbih0aGlzLl9pbnRlcm5hbFN0YXRlLm9sZFZhbCwgdGhpcy5faW50ZXJuYWxTdGF0ZS5uZXdWYWwsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgcHJvZ3Jlc3MgYmFyYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IHwgSWd4Q2lyY3VsYXJCYXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICAgYWxlcnQobWF4KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50OyAvLyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50XG4gICAgICogcHVibGljIHZhbHVlUGVyY2VudChldmVudCl7XG4gICAgICogICAgIGxldCBwZXJjZW50VmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50O1xuICAgICAqICAgICBhbGVydChwZXJjZW50VmFsdWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZhbHVlSW5QZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRvUGVyY2VudCh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICAgYWxlcnQodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb24gJiYgdGhpcy5fYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ2ZpbmlzaGVkJyB8fCB2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWxJblJhbmdlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5tYXgpO1xuXG4gICAgICAgIGlmIChpc05hTih2YWxJblJhbmdlKSB8fCB0aGlzLl92YWx1ZSA9PT0gdmFsIHx8IHRoaXMuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24odGhpcy5fdmFsdWUsIHZhbEluUmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5pdFZhbHVlID0gdmFsSW5SYW5nZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKG9sZFZhbCwgbmV3VmFsLCBtYXhVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAob2xkVmFsID09PSBuZXdWYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRWYWx1ZXMgPSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IG9sZFZhbFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHN0ZXBEaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbkZsb3cob2xkVmFsLCBuZXdWYWwpO1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VG9QZXJjZW50ID0gdG9QZXJjZW50KG5ld1ZhbCwgdGhpcy5tYXgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVG9QZXJjZW50ID0gdG9QZXJjZW50KG9sZFZhbCwgdGhpcy5tYXgpO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uIC8gTWF0aC5hYnMobmV3VG9QZXJjZW50IC0gb2xkVG9QZXJjZW50KSAvICh0aGlzLl9zdGVwID8gdGhpcy5fc3RlcCA6IDEpO1xuICAgICAgICAgICAgdGhpcy5ydW5BbmltYXRpb24obmV3VmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5pbmNyZWFzZShuZXdWYWwsIHN0ZXBEaXJlY3Rpb24pLCBkdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKG5ld1ZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4VXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzc0NoYW5nZWQuZW1pdChjaGFuZ2VkVmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluY3JlYXNlKG5ld1ZhbHVlOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRvUGVyY2VudChuZXdWYWx1ZSwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZUluUmFuZ2UodGhpcy5fdmFsdWUsIHRoaXMuX21heCkgKyBzdGVwO1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHRoaXMudmFsdWVJblBlcmNlbnQgPj0gdGFyZ2V0VmFsdWUpIHx8IChzdGVwIDwgMCAmJiB0aGlzLnZhbHVlSW5QZXJjZW50IDw9IHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA8IHByZXZWYWx1ZSA/IHRoaXMuc3RlcCA6IC10aGlzLnN0ZXA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJ1bkFuaW1hdGlvbih2YWx1ZTogbnVtYmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3ModmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZUluUmFuZ2UodmFsLCB0aGlzLl9tYXgpO1xuICAgICAgICAvLyB0aGlzLnZhbHVlSW5QZXJjZW50ID0gdG9QZXJjZW50KHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy5ydW5BbmltYXRpb24odmFsKTtcbiAgICB9XG59XG5sZXQgTkVYVF9MSU5FQVJfSUQgPSAwO1xubGV0IE5FWFRfQ0lSQ1VMQVJfSUQgPSAwO1xubGV0IE5FWFRfR1JBRElFTlRfSUQgPSAwO1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtbGluZWFyLWJhcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3NEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1pbicpXG4gICAgcHVibGljIHZhbHVlTWluID0gMDtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtbGluZWFyLWJhcic7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIHN0cmlwZWQgc3R5bGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdHJpcGVkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdHJpcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0taW5kZXRlcm1pbmF0ZScpXG4gICAgcHVibGljIGdldCBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGByb2xlYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBwcm9ncmVzc2JhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciByb2xlPVwicHJvZ3Jlc3NiYXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb2xlID0gJ3Byb2dyZXNzYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpZF09XCInaWd4LWxpbmVhci1iYXItNTUnXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1saW5lYXItYmFyLSR7TkVYVF9MSU5FQVJfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zIC0gYElneFRleHRBbGlnbi5TVEFSVGAgKGRlZmF1bHQpLCBgSWd4VGV4dEFsaWduLkNFTlRFUmAsIGBJZ3hUZXh0QWxpZ24uRU5EYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIHBvc2l0aW9uQ2VudGVyOiBJZ3hUZXh0QWxpZ247XG4gICAgICogcHVibGljIG5nT25Jbml0KCkge1xuICAgICAqICAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKiB9XG4gICAgICogIC8vLi4uXG4gICAgICogYGBgXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRBbGlnbjogSWd4VGV4dEFsaWduID0gSWd4VGV4dEFsaWduLlNUQVJUO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0IHRvIGJlIHZpc2libGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRlZmF1bHRcIiBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZXJyb3JcIiBbdGV4dFRvcF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCB0eXBlIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBQb3NzaWJsZSBvcHRpb25zIC0gYGRlZmF1bHRgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBhbmQgYGVycm9yYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJlcnJvclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZSA9ICdkZWZhdWx0JztcblxuICAgIEBWaWV3Q2hpbGQoJ2luZGljYXRvcicsIHtzdGF0aWM6IHRydWV9KVxuICAgIHByaXZhdGUgX3Byb2dyZXNzSW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgd2lkdGg6ICcwJSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLWRhbmdlcicpXG4gICAgcHVibGljIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLkVSUk9SO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmZvJylcbiAgICBwdWJsaWMgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5JTkZPO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS13YXJuaW5nJylcbiAgICBwdWJsaWMgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5XQVJOSU5HO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdWNjZXNzJylcbiAgICBwdWJsaWMgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5TVUNDRVNTO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbihNSU5fVkFMVUUsIHRoaXMuX2luaXRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRJbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuQW5pbWF0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUGVyY2VudCA9IHRoaXMubWF4IDw9IDAgPyAwIDogdG9QZXJjZW50KHZhbHVlLCB0aGlzLm1heCk7XG5cbiAgICAgICAgY29uc3QgRlJBTUVTID0gW107XG4gICAgICAgIEZSQU1FU1swXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLndpZHRoID0gdmFsdWVJblBlcmNlbnQgKyAnJSc7XG4gICAgICAgIEZSQU1FU1sxXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB0aGlzLl9wcm9ncmVzc0luZGljYXRvci5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1jaXJjdWxhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2NpcmN1bGFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1jaXJjdWxhci1iYXItJHtORVhUX0NJUkNVTEFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhlIGBpZ3hDaXJjdWxhckJhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIHRleHQ9XCJQcm9ncmVzc1wiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRleHQgPSB0aGlzLmNpcmN1bGFyQmFyLnRleHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgdGV4dFRlbXBsYXRlOiBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgZ3JhZGllbnRUZW1wbGF0ZTogSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZTtcblxuICAgIEBWaWV3Q2hpbGQoJ2NpcmNsZScsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfc3ZnQ2lyY2xlOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBncmFkaWVudElkID0gYGlneC1jaXJjdWxhci1ncmFkaWVudC0ke05FWFRfR1JBRElFTlRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB7IHZhbHVlOiB0aGlzLnZhbHVlLCB2YWx1ZUluUGVyY2VudDogdGhpcy52YWx1ZUluUGVyY2VudCwgbWF4OiB0aGlzLm1heCB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2lyY2xlUmFkaXVzID0gNDY7XG4gICAgcHJpdmF0ZSBfY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5fY2lyY2xlUmFkaXVzO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVIgPSAxMDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTiA9IC4yO1xuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMjg5LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZGlyZWN0aW9uYWxpdHk6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKE1JTl9WQUxVRSwgdGhpcy5faW5pdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fY29udGVudEluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgYHVybCgjJHt0aGlzLmdyYWRpZW50SWR9KWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0ZXh0Q29udGVudCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cblxuICAgIHB1YmxpYyBydW5BbmltYXRpb24odmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uICYmIHRoaXMuX2FuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdmaW5pc2hlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5QZXJjZW50ID0gdGhpcy5tYXggPD0gMCA/IDAgOiB0b1BlcmNlbnQodmFsdWUsIHRoaXMubWF4KTtcblxuICAgICAgICBjb25zdCBGUkFNRVMgPSBbXTtcbiAgICAgICAgRlJBTUVTWzBdID0gey4uLnRoaXMuYW5pbWF0aW9uU3RhdGV9O1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuc3Ryb2tlRGFzaG9mZnNldCA9IHRoaXMuZ2V0UHJvZ3Jlc3ModmFsdWVJblBlcmNlbnQpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnN0cm9rZU9wYWNpdHkgPSB0b1BlcmNlbnQodmFsdWUsIHRoaXMubWF4KSAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTjtcblxuICAgICAgICBGUkFNRVNbMV0gPSB7XG4gICAgICAgICAgICAuLi50aGlzLmFuaW1hdGlvblN0YXRlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShGUkFNRVMsIHtcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICAgICAgICAgIGZpbGw6ICdmb3J3YXJkcycsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uYWxpdHkucnRsID9cbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgKyAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApIDpcbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgLSAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZhbHVlSW5SYW5nZSA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluID0gMCk6IG51bWJlciA9PiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudCA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4gICFtYXggPyAwIDogTWF0aC5mbG9vcigxMDAgKiB2YWx1ZSAvIG1heCk7XG5cbmV4cG9ydCBjb25zdCB0b1ZhbHVlID0gKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBtYXggKiB2YWx1ZSAvIDEwMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSxcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQsXG4gICAgICAgIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQsXG4gICAgICAgIElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUsXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQcm9ncmVzc0Jhck1vZHVsZSB7IH1cblxuIiwiPGRpdiBjbGFzcz1cImlneC1saW5lYXItYmFyX19iYXNlXCI+XG4gICAgPGRpdiAjaW5kaWNhdG9yIGNsYXNzPVwiaWd4LWxpbmVhci1iYXJfX2luZGljYXRvclwiIFtzdHlsZS53aWR0aF09XCIwXCI+PC9kaXY+XG48L2Rpdj5cblxuPHNwYW5cbiAgICBjbGFzcz1cImlneC1saW5lYXItYmFyX192YWx1ZVwiXG4gICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAnaWd4LWxpbmVhci1iYXJfX3ZhbHVlLS1zdGFydCc6IHRleHRBbGlnbiA9PT0gJ3N0YXJ0JyxcbiAgICAgICAgJ2lneC1saW5lYXItYmFyX192YWx1ZS0tY2VudGVyJzogdGV4dEFsaWduID09PSAnY2VudGVyJyxcbiAgICAgICAgJ2lneC1saW5lYXItYmFyX192YWx1ZS0tZW5kJzogdGV4dEFsaWduID09PSAnZW5kJyxcbiAgICAgICAgJ2lneC1saW5lYXItYmFyX192YWx1ZS0tdG9wJzogdGV4dFRvcCxcbiAgICAgICAgJ2lneC1saW5lYXItYmFyX192YWx1ZS0taGlkZGVuJzogIXRleHRWaXNpYmlsaXR5XG4gICAgfVwiPlxuICAgICAgICB7e3RleHQgPyB0ZXh0IDogdmFsdWVJblBlcmNlbnQgKyAnJSd9fVxuPC9zcGFuPlxuIiwiPHN2ZyAjc3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB2ZXJzaW9uPVwiMS4xXCJcbiAgICB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIlxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiXG4gICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ2YWx1ZVwiPlxuICAgIDxzdmc6Y2lyY2xlIGNsYXNzPVwiaWd4LWNpcmN1bGFyLWJhcl9faW5uZXJcIiBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0NlwiIC8+XG4gICAgPHN2ZzpjaXJjbGUgI2NpcmNsZSBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX291dGVyXCIgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDZcIiAvPlxuICAgIDxzdmc6dGV4dCAqbmdJZj1cInRleHRWaXNpYmlsaXR5XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiB4PVwiNTBcIiB5PVwiNjBcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRleHRUZW1wbGF0ZSA/IHRleHRUZW1wbGF0ZS50ZW1wbGF0ZSA6IGRlZmF1bHRUZXh0VGVtcGxhdGU7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvc3ZnOnRleHQ+XG5cbiAgICA8c3ZnOmRlZnM+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiZ3JhZGllbnRUZW1wbGF0ZSA/IGdyYWRpZW50VGVtcGxhdGUudGVtcGxhdGUgOiBkZWZhdWx0R3JhZGllbnRUZW1wbGF0ZTtcbiAgICAgICAgICAgIGNvbnRleHQ6IHsgJGltcGxpY2l0OiBncmFkaWVudElkIH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9zdmc6ZGVmcz5cblxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFRleHRUZW1wbGF0ZT5cbiAgICAgICAgPHN2Zzp0c3BhbiBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX3RleHRcIj5cbiAgICAgICAgICAgIHt7dGV4dENvbnRlbnQgPyB0ZXh0Q29udGVudDogdmFsdWVJblBlcmNlbnQgKyAnJSd9fVxuICAgICAgICA8L3N2Zzp0c3Bhbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0R3JhZGllbnRUZW1wbGF0ZT5cbiAgICAgICAgPHN2ZzpsaW5lYXJHcmFkaWVudCBbaWRdPVwiZ3JhZGllbnRJZFwiIGdyYWRpZW50VHJhbnNmb3JtPVwicm90YXRlKDkwKVwiPlxuICAgICAgICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgICBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX2dyYWRpZW50LXN0YXJ0XCIgLz5cbiAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgY2xhc3M9XCJpZ3gtY2lyY3VsYXItYmFyX19ncmFkaWVudC1lbmRcIiAvPlxuICAgICAgICA8L3N2ZzpsaW5lYXJHcmFkaWVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9zdmc+XG5cbiJdfQ==